# BACKUP CRIADO EM: 2025-04-17 07:58:48
# Total de arquivos: 6

# INÍCIO DO ARQUIVO: WhatsApp_Manager.py (1/6) 
import env_config
import storage_manager
import requests
import os
import json
from datetime import datetime
from qwen1 import process_message
from media_handler import MediaHandler
from audio_processor import AudioProcessor
from google.cloud import storage

class WhatsAppManager:
    def __init__(self):
        self.VERIFICATION_TOKEN = "EAAJjZBmxpkYgBOyEx31oz53K3694dZCg81dZA17ym3W9rCFjmax29HMwcdgq8iZBawUoNw1vzTlYSGAbIWTN4MRkWZBA0wMpwfLfI6dHaaMyhUZC1qZADUbZBZCNMhOw8a0AI2sBHpBLtbEbMrhBGZBNh81teK7z0ZBX338LZBTHRXYr96YTytPiv1JRD5Vyiis5pl5yhpUHzjHDhgZDZD"
        self.WHATSAPP_TOKEN = "EAAJjZBmxpkYgBOyEx31oz53K3694dZCg81dZA17ym3W9rCFjmax29HMwcdgq8iZBawUoNw1vzTlYSGAbIWTN4MRkWZBA0wMpwfLfI6dHaaMyhUZC1qZADUbZBZCNMhOw8a0AI2sBHpBLtbEbMrhBGZBNh81teK7z0ZBX338LZBTHRXYr96YTytPiv1JRD5Vyiis5pl5yhpUHzjHDhgZDZD"
        self.PHONE_NUMBER_ID = "637338086121702"
        self.conversations = {}
        self.last_message_id = None
        # Configuração do Google Cloud Storage
        self.storage_client = storage.Client()
        self.CONVERSATION_BUCKET = "aerial-acre-455118-a9-conversations"
        
        self.media_handler = MediaHandler(
            phone_number_id=self.PHONE_NUMBER_ID, 
            whatsapp_token=self.WHATSAPP_TOKEN
        )
        
        # Para compatibilidade local, cria o diretório de conversas se estiver rodando localmente
        self.CONVERSATION_DIR = "conversations"
        if not os.path.exists(self.CONVERSATION_DIR):
            os.makedirs(self.CONVERSATION_DIR)
            
        self.load_conversations()
        self.audio_processor = AudioProcessor(model_size="base")

    def get_last_message_id(self):
        return self.last_message_id
    
    def update_last_message(self, new_id):
        self.last_message_id = new_id
        return True

    def get_conversation_history(self, phone_number):
        return self.conversations.get(phone_number, {})
    
    def toggle_conversation_mode(self, phone_number):
        if phone_number in self.conversations:
            current_mode = self.conversations[phone_number].get("mode", "auto")
            new_mode = "human" if current_mode == "auto" else "auto"
            self.conversations[phone_number]["mode"] = new_mode
            self.save_conversation(phone_number)
            print(f"Modo da conversa com {phone_number} alterado para: {new_mode}")
            return new_mode
        print(f"Tentativa de alternar modo para número inexistente: {phone_number}")
        return None

    def load_conversations(self):
        try:
            # Carregar conversas usando o gerenciador de armazenamento
            print("Carregando conversas...")
            
            # No GCS, vamos listar todos os arquivos no bucket
            if env_config.IS_CLOUD_ENVIRONMENT:
                storage_client = storage.Client()
                bucket = storage_client.bucket(env_config.CONVERSATIONS_BUCKET)
                blobs = bucket.list_blobs()
                
                for blob in blobs:
                    if blob.name.endswith('.json'):
                        try:
                            phone_number = blob.name.split(".")[0]
                            data = storage_manager.load_json(blob.name)
                            
                            if data:
                                # Processamento normal do arquivo de conversa
                                self.conversations[phone_number] = data
                                # Garantir que tenha o campo mode
                                if "mode" not in self.conversations[phone_number]:
                                    self.conversations[phone_number]["mode"] = "auto"
                        except Exception as e:
                            print(f"Erro ao carregar arquivo {blob.name}: {str(e)}")
            else:
                # Localmente, vamos listar arquivos no diretório
                if not os.path.exists(env_config.LOCAL_CONVERSATIONS_DIR):
                    os.makedirs(env_config.LOCAL_CONVERSATIONS_DIR)
                    return
                    
                for filename in os.listdir(env_config.LOCAL_CONVERSATIONS_DIR):
                    if filename.endswith('.json'):
                        try:
                            phone_number = filename.split(".")[0]
                            filepath = os.path.join(env_config.LOCAL_CONVERSATIONS_DIR, filename)
                            data = storage_manager.load_json(filepath)
                            
                            if data:
                                # Processamento normal do arquivo de conversa
                                self.conversations[phone_number] = data
                                # Garantir que tenha o campo mode
                                if "mode" not in self.conversations[phone_number]:
                                    self.conversations[phone_number]["mode"] = "auto"
                        except Exception as e:
                            print(f"Erro ao carregar arquivo {filepath}: {str(e)}")
                
            print(f"{len(self.conversations)} conversas carregadas.")
        except Exception as e:
            print(f"Erro ao carregar conversas: {str(e)}")
    def _load_conversations_local(self):
        """Método auxiliar para carregar conversas do sistema de arquivos local (apenas para desenvolvimento)"""
        try:
            if not os.path.exists(self.CONVERSATION_DIR):
                os.makedirs(self.CONVERSATION_DIR)
                print("Diretório de conversas criado.")
                return
                
            for filename in os.listdir(self.CONVERSATION_DIR):
                if filename.endswith('.json'):
                    phone_number = filename.split(".")[0]
                    filepath = os.path.join(self.CONVERSATION_DIR, filename)
                    try:
                        with open(filepath, "r", encoding='utf-8') as file:
                            data = json.load(file)
                            
                            # Converte formato antigo para novo formato se necessário
                            if "messages" in data and isinstance(data["messages"], list):
                                self.conversations[phone_number] = {
                                    "name": data.get("name", "Cliente"),
                                    "profile_pic": data.get("profile_pic", ""),
                                    "mode": data.get("mode", "auto"),
                                    "messages": []
                                }
                                
                                for msg in data["messages"]:
                                    if "text" in msg and "type" not in msg:
                                        self.conversations[phone_number]["messages"].append({
                                            "type": "text",
                                            "content": msg["text"],
                                            "from": msg["from"],
                                            "timestamp": msg.get("timestamp", datetime.now().strftime("%H:%M %d/%m/%y"))
                                        })
                                    else:
                                        self.conversations[phone_number]["messages"].append(msg)
                            else:
                                self.conversations[phone_number] = data
                            
                            if "mode" not in self.conversations[phone_number]:
                                self.conversations[phone_number]["mode"] = "auto"
                    except Exception as e:
                        print(f"Erro ao carregar arquivo local {filepath}: {str(e)}")
                        continue
                        
            print(f"{len(self.conversations)} conversas carregadas localmente.")
        except Exception as e:
            print(f"Erro ao carregar conversas localmente: {str(e)}")

    def save_conversation(self, phone_number):
        try:
            # Obter os dados da conversa
            conversation_data = self.conversations.get(phone_number, {})
            
            # Caminho do arquivo
            file_path = f"{phone_number}.json"
            
            # Salvar usando o gerenciador de armazenamento
            storage_manager.save_json(file_path, conversation_data)
            print(f"Conversa com {phone_number} salva.")
            
        except Exception as e:
            print(f"Erro ao salvar conversa: {str(e)}")

    def _save_conversation_local(self, phone_number):
        """Método auxiliar para salvar conversas localmente (apenas para desenvolvimento)"""
        try:
            if not os.path.exists(self.CONVERSATION_DIR):
                os.makedirs(self.CONVERSATION_DIR)
                
            filepath = os.path.join(self.CONVERSATION_DIR, f"{phone_number}.json")
            with open(filepath, "w", encoding='utf-8') as file:
                json.dump(self.conversations.get(phone_number, {}), file, indent=4, ensure_ascii=False)
            print(f"Conversa com {phone_number} salva localmente.")
        except Exception as e:
            print(f"Erro ao salvar conversa localmente: {str(e)}")

    def handle_incoming_message(self, data):
        try:
            print(f"Dados recebidos via webhook: {data}")
            phone_number = None
            if "messages" in data.get("entry", [{}])[0].get("changes", [{}])[0].get("value", {}):
                phone_number = data.get("entry", [{}])[0].get("changes", [{}])[0].get("value", {}).get("contacts", [{}])[0].get("wa_id", "")
                client_name = data.get("entry", [{}])[0].get("changes", [{}])[0].get("value", {}).get("contacts", [{}])[0].get("profile", {}).get("name", "Desconhecido")
                
                # Inicializa a conversa se não existir
                if phone_number not in self.conversations:
                    self.conversations[phone_number] = {
                        "name": client_name,
                        "profile_pic": "",
                        "mode": "auto",
                        "messages": [],
                        "processed_message_ids": []  # Inicializa a lista de IDs processados
                    }
                
                # Verifica se existe o campo processed_message_ids
                if "processed_message_ids" not in self.conversations[phone_number]:
                    self.conversations[phone_number]["processed_message_ids"] = []
                
                message = data.get("entry", [{}])[0].get("changes", [{}])[0].get("value", {}).get("messages", [{}])[0]
                message_id = message.get("id", "")
                
                # Verifica se a mensagem já foi processada
                if message_id in self.conversations[phone_number]["processed_message_ids"]:
                    print(f"Mensagem {message_id} já foi processada anteriormente. Ignorando.")
                    return phone_number
                
                profile_pic = data.get("entry", [{}])[0].get("changes", [{}])[0].get("value", {}).get("contacts", [{}])[0].get("profile", {}).get("profile_picture", "")
                if profile_pic:
                    print(f"FOTO DE PERFIL DETECTADA: {profile_pic}")
                    self.conversations[phone_number]["profile_pic"] = profile_pic
                
                message_type = message.get("type", "")
                message_content = None
                media_url = None
                
                if message_type == "text":
                    message_content = message.get("text", {}).get("body", "")
                    media_url = None
                    message_obj = {
                        "type": "text",
                        "content": message_content,
                        "from": "cliente",
                        "timestamp": datetime.now().strftime("%H:%M %d/%m/%y")
                    }
                    
                elif message_type in ["image", "audio", "video", "document"]:
                    media_id = message.get(message_type, {}).get("id", "")
                    print(f"DEBUG - ID de mídia de {message_type} recebido: {media_id}")
                    
                    if not media_id:
                        print(f"ERRO - ID de mídia de {message_type} está vazio ou nulo!")
                        media_url = None
                    else:
                        media_url = self.media_handler.download_media(media_id, self.WHATSAPP_TOKEN)
                        print(f"Mídia baixada com URL: {media_url}")
                    
                    caption = message.get(message_type, {}).get("caption", "")
                    
                    # Processar áudio para texto se for mensagem de áudio
                    transcription = ""
                    
                    if message_type == "audio" and media_url:
                        # Verificar se media_url já tem o prefixo "media\"
                        audio_path = media_url
                        if not audio_path.startswith('media\\') and not audio_path.startswith('media/'):
                            audio_path = os.path.join('media', audio_path)
                        
                        print(f"Caminho para transcrição: {audio_path}")
                        # Transcrever o áudio
                        transcription = self.audio_processor.transcribe_audio(audio_path)
                        print(f"Áudio transcrito: {transcription}")
                    
                    message_obj = {
                        "type": message_type,
                        "content": caption,
                        "media_url": media_url,
                        "from": "cliente",
                        "timestamp": datetime.now().strftime("%H:%M %d/%m/%y")
                    }
                    
                    # Adicionar a transcrição ao objeto da mensagem, se houver
                    if message_type == "audio" and transcription:
                        message_obj["transcription"] = transcription
                else:
                    print(f"Tipo de mensagem desconhecido: {message_type}")
                    return None
                
                self.conversations[phone_number]["messages"].append(message_obj)
                
                # Após processar a mensagem, adiciona o ID à lista de processados
                self.conversations[phone_number]["processed_message_ids"].append(message_id)
                self.save_conversation(phone_number)
                
                print(f"Mensagem do cliente {client_name} ({phone_number}) recebida: Tipo={message_type}")

                if self.conversations[phone_number]["mode"] == "auto":
                    self.conversations[phone_number]["status"] = "processing"
                    self.save_conversation(phone_number)

                    resposta_qwen = None
                    try:
                        if message_type == "text":
                            resposta_qwen = process_message(message_content, phone_number)
                        elif message_type == "audio" and transcription:
                        # Usar o texto transcrito do áudio para processar a resposta
                            resposta_qwen = process_message(transcription, phone_number)
                        else:
                            media_desc = f"[Cliente enviou {message_type}]"
                            if caption:
                                media_desc += f" com a legenda: '{caption}'"
                            resposta_qwen = process_message(media_desc, phone_number)
        
                        # Enviar a resposta ao cliente
                        if resposta_qwen:
                            self.send_message_to_whatsapp(phone_number, resposta_qwen)
        
                        # Atualizar status para "idle" após processamento bem-sucedido
                        self.conversations[phone_number]["status"] = "idle"
                        self.save_conversation(phone_number)
                    except Exception as e:
                        print(f"Erro ao processar resposta automática: {str(e)}")
                        # Atualizar status para "error" em caso de falha
                        self.conversations[phone_number]["status"] = "error"
                        self.save_conversation(phone_number)
                        import traceback
                        traceback.print_exc()
                
                # Retorna o número de telefone para ser usado pelo emissor de eventos Socket.IO
                return phone_number

        except Exception as e:
            print(f"Erro ao processar mensagem: {str(e)}")
            import traceback
            traceback.print_exc()
            return None


    def send_message_to_whatsapp(self, to_number, message, media_type=None, media_path=None):
        try:
            print(f"DEBUG: Iniciando envio - Tipo: {media_type}, Mídia: {media_path}")
            
            url = f"https://graph.facebook.com/v16.0/{self.PHONE_NUMBER_ID}/messages"
            headers = {
                "Authorization": f"Bearer {self.WHATSAPP_TOKEN}",
                "Content-Type": "application/json"
            }

            # Determina o modo atual da conversa (auto ou humano)
            if to_number not in self.conversations:
                self.conversations[to_number] = {
                    "name": "Desconhecido",
                    "profile_pic": "",
                    "mode": "auto",
                    "messages": []
                }
            
            sender = "qwen" if self.conversations[to_number]["mode"] == "auto" else "vendedor"
            timestamp = datetime.now().strftime("%H:%M %d/%m/%y")
            
            # Mensagem de texto simples (sem mídia)
            if media_type is None:
                payload = {
                    "messaging_product": "whatsapp",
                    "to": to_number,
                    "type": "text",
                    "text": {
                        "body": message
                    }
                }
                
                # Registra na conversa
                self.conversations[to_number]["messages"].append({
                    "type": "text",
                    "content": message,
                    "from": sender,
                    "timestamp": timestamp
                })
            else:
                # Lida com envio de mídia
                if media_path.startswith(('http://', 'https://')):
                    # URL externa
                    media_payload = {
                        "link": media_path
                    }
                    if media_type != "audio" and message:
                        media_payload["caption"] = message
                else:
                    # Arquivo local ou no Cloud Storage
                    print(f"DEBUG: Enviando mídia do tipo {media_type}: {media_path}")
                    
                    # Upload de mídia com tratamento de erro
                    try:
                        # INÍCIO DOS LOGS DE ÁUDIO
                        if media_type == "audio":
                            mime_type = "voide/ogg" if media_type == "audio" else None
                            print(f"DEBUG ÁUDIO: Iniciando processamento de mensagem de áudio")
                            print(f"DEBUG ÁUDIO: Caminho do arquivo: {media_path}")
                            print(f"DEBUG ÁUDIO: MIME type sendo usado: {mime_type or 'Não especificado (será detectado)'}")
                        # FIM DOS LOGS DE ÁUDIO
                        
                        if media_type == "audio":
                            mime_type = "audio/ogg;"
                            print("FORÇANDO ÁUDIO COMO audio/ogg")
                            media_id = self.media_handler.upload_media(media_path, self.WHATSAPP_TOKEN, mime_type)
                            
                            payload = {
                                "messaging_product": "whatsapp",
                                "to": to_number,
                                "type": "audio",
                                "audio": {
                                    "id": media_id
                                }
                            }
                        else:
                            mime_type = None
                            media_id = self.media_handler.upload_media(media_path, self.WHATSAPP_TOKEN, mime_type)

                        # MAIS LOGS DE ÁUDIO
                        if media_type == "audio":
                            print(f"DEBUG ÁUDIO: Resultado do upload: media_id={media_id}")
                            if not media_id:
                                print(f"DEBUG ÁUDIO: FALHA no upload do áudio - verifique logs anteriores")
                            else:
                                print(f"DEBUG ÁUDIO: Upload do áudio bem-sucedido, continuando com envio")

                        if not media_id:
                            print(f"Falha ao obter ID de mídia para {media_path}")
                            return False

                        media_payload = {
                            "id": media_id
                        }
                        # Adiciona legenda apenas para mídias que não são áudio
                        if media_type != "audio" and message:
                            media_payload["caption"] = message
                            
                        print(f"DEBUG: Media ID obtido: {media_id}")
                    except Exception as e:
                        print(f"Erro no upload de mídia: {str(e)}")
                        return False

                # Payload final para envio de mídia
                payload = {
                    "messaging_product": "whatsapp",
                    "to": to_number,
                    "type": media_type,
                    media_type: media_payload
                }
                
                # Registra na conversa
                self.conversations[to_number]["messages"].append({
                    "type": media_type,
                    "content": message,
                    "media_url": media_path,
                    "from": sender,
                    "timestamp": timestamp
                })

            print(f"Enviando payload: {payload}")  # Debug para ver o payload enviado
            response = requests.post(url, json=payload, headers=headers)
            print(f"RESPOSTA DETALHADA DA API: Status={response.status_code}, Corpo={response.text}")

            # Verifica a resposta
            if response.status_code == 200:
                print(f"Mensagem enviada com sucesso para {to_number}")
                self.save_conversation(to_number)
                return True
            else:
                print(f"Falha ao enviar mensagem para {to_number}: {response.text}")
                return False
        except Exception as e:
            print(f"Erro ao enviar mensagem: {str(e)}")
            import traceback
            traceback.print_exc()
            return False
    
    def delete_conversation(self, phone_number):
        """Remove uma conversa do dicionário de conversas"""
        try:
            if phone_number in self.conversations:
                del self.conversations[phone_number]
                print(f"[SUCESSO] Conversa {phone_number} deletada")  # Usando print em vez de logger
                return True
            print(f"[AVISO] Conversa {phone_number} não encontrada")  # Usando print em vez de logger
            return False
        except Exception as e:
            print(f"[ERRO] Falha ao deletar {phone_number}: {str(e)}")  # Usando print em vez de logger
            return False
# FIM DO ARQUIVO: WhatsApp_Manager.py 

# INÍCIO DO ARQUIVO: main.py (2/6) 
from WhatsApp_Manager import WhatsAppManager
from flask import Flask, render_template, request, jsonify, send_from_directory, redirect
import os
import logging
from google.cloud import storage
from flask_cors import CORS  
from datetime import datetime

# Configuração de logging
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    handlers=[logging.StreamHandler()])
logger = logging.getLogger(__name__)

app = Flask(__name__, template_folder="templates", static_folder="static")
CORS(app)

# Inicializa o gerenciador do WhatsApp
whatsapp_manager = WhatsAppManager()

# Inicializa o cliente do Google Cloud Storage
storage_client = storage.Client()
media_bucket_name = "aerial-acre-455118-a9-media"

# Rota para servir arquivos de mídia
@app.route('/media/<path:filename>')
def serve_media(filename):
    try:
        logger.info(f"Solicitação de mídia: {filename}")
        
        # Tenta servir do Google Cloud Storage
        bucket = storage_client.bucket(media_bucket_name)
        blob = bucket.blob(filename)
        
        if blob.exists():
            # Gera URL pública e redireciona
            public_url = blob.public_url
            logger.info(f"Redirecionando para URL pública: {public_url}")
            return redirect(public_url)
        
        # Se não encontrou no GCS, tenta localmente (para desenvolvimento)
        # Determina o tipo de mídia com base no caminho
        if filename.startswith('images/'):
            return send_from_directory('media', filename)
        elif filename.startswith('audio/'):
            return send_from_directory('media', filename)
        elif filename.startswith('video/'):
            return send_from_directory('media', filename)
        elif filename.startswith('documents/'):
            return send_from_directory('media', filename)
        else:
            logger.warning(f"Tipo de mídia não suportado: {filename}")
            return "Arquivo não encontrado", 404
    except Exception as e:
        logger.error(f"Erro ao servir mídia {filename}: {str(e)}")
        # Tenta localmente como fallback
        try:
            # Determina o tipo de mídia com base no caminho
            if filename.startswith('images/') or filename.startswith('audio/') or filename.startswith('video/') or filename.startswith('documents/'):
                return send_from_directory('media', filename)
            else:
                return "Arquivo não encontrado", 404
        except:
            return "Erro ao servir mídia", 500

@app.route('/')
def index():
    try:
        # Renderiza a página inicial com as conversas existentes
        conversations = whatsapp_manager.conversations
        logger.info(f"Página inicial carregada com {len(conversations)} conversas")
        return render_template('index.html', conversations=conversations)
    except Exception as e:
        logger.error(f"Erro na página inicial: {str(e)}")
        return "Erro ao carregar a página", 500

@app.route('/send_location', methods=['POST'])
def send_location():
    try:
        data = request.json
        to_number = data.get("to_number")
        latitude = data.get("latitude")
        longitude = data.get("longitude")
        
        logger.info(f"Enviando localização para {to_number}: {latitude}, {longitude}")
        
        # Crie uma mensagem com a localização
        message = f"Minha localização atual: https://maps.google.com/?q={latitude},{longitude}"
        
        # Use a função existente para enviar mensagem de texto
        success = whatsapp_manager.send_message_to_whatsapp(to_number, message)
        
        if success:
            logger.info(f"Localização enviada com sucesso para {to_number}")
            return jsonify({"status": "success"}), 200
        else:
            logger.warning(f"Falha ao enviar localização para {to_number}")
            return jsonify({"status": "error"}), 500
    except Exception as e:
        logger.error(f"Erro ao enviar localização: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/send_message', methods=['POST'])
def send_message():
    try:
        logger.info("ROTA SEND_MESSAGE: Dados recebidos: %s", request.json)
        # Envia uma mensagem para um número via API do WhatsApp
        data = request.json
        to_number = data.get("to_number")
        message = data.get("message")
        media_path = data.get("media_path")
        media_type = data.get("media_type")
        
        logger.info(f"Enviando mensagem para {to_number}. Mídia: {media_type if media_type else 'Nenhuma'}")
        
        # Primeiro definimos a variável success
        if media_path and media_type:
            success = whatsapp_manager.send_message_to_whatsapp(to_number, message, media_type, media_path)
        else:
            success = whatsapp_manager.send_message_to_whatsapp(to_number, message)
        
        # Depois verificamos seu valor
        if success:
            logger.info(f"Mensagem enviada com sucesso para {to_number}")
            return jsonify({"status": "success"}), 200
        else:
            logger.warning(f"Falha ao enviar mensagem para {to_number}")
            return jsonify({"status": "error"}), 500
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/toggle_mode/<phone_number>', methods=['POST'])
def toggle_conversation_mode(phone_number):
    try:
        # Alterna o modo da conversa entre automático e humano
        new_mode = whatsapp_manager.toggle_conversation_mode(phone_number)
        if new_mode:
            logger.info(f"Modo de conversa alterado para {phone_number}: {new_mode}")
            return jsonify({"status": "success", "mode": new_mode}), 200
        else:
            logger.warning(f"Conversa não encontrada para alternar modo: {phone_number}")
            return jsonify({"status": "error", "message": "Conversa não encontrada"}), 404
    except Exception as e:
        logger.error(f"Erro ao alternar modo de conversa: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/upload_media', methods=['POST'])
def upload_media():
    try:
        # Endpoint para fazer upload de mídia do cliente
        if 'file' not in request.files:
            logger.warning("Tentativa de upload sem arquivo")
            return jsonify({"status": "error", "message": "Nenhum arquivo enviado"}), 400
        
        file = request.files['file']
        if file.filename == '':
            logger.warning("Nome de arquivo vazio no upload")
            return jsonify({"status": "error", "message": "Nome de arquivo vazio"}), 400
        
        # Determinar o tipo de mídia
        if file.content_type.startswith('image/'):
            media_type = 'images'
        elif file.content_type.startswith('audio/'):
            media_type = 'audio'
        elif file.content_type.startswith('video/'):
            media_type = 'video'
        else:
            media_type = 'documents'
        
        # Salvar o arquivo no Google Cloud Storage
        filename = f"{file.filename}"
        gcs_path = f"{media_type}/{filename}"
        
        # Fazer upload para o GCS
        bucket = storage_client.bucket(media_bucket_name)
        blob = bucket.blob(gcs_path)
        blob.upload_from_string(
            file.read(),
            content_type=file.content_type
        )
        
        # Tornar o arquivo publicamente acessível
        blob.make_public()
        
        logger.info(f"Mídia carregada para o GCS: {gcs_path}")
        
        # Para desenvolvimento local, também salva localmente
        try:
            media_dir = os.path.join('media', media_type)
            if not os.path.exists(media_dir):
                os.makedirs(media_dir)
                
            filepath = os.path.join(media_dir, filename)
            file.seek(0)  # Voltar ao início do arquivo
            file.save(filepath)
            logger.info(f"Mídia também salva localmente em: {filepath}")
        except Exception as e:
            logger.warning(f"Não foi possível salvar localmente (isso é normal no App Engine): {str(e)}")
        
        return jsonify({
            "status": "success", 
            "media_path": gcs_path, 
            "media_type": media_type.rstrip('s')  # Remove o 's' para corresponder ao tipo da API
        }), 200
    except Exception as e:
        logger.error(f"Erro no upload de mídia: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        data = request.json
        logger.info("Mensagem recebida via webhook")
        
        # Extrai o número de telefone da mensagem
        phone_number = None
        if "entry" in data and len(data["entry"]) > 0:
            phone_number = data.get("entry", [{}])[0].get("changes", [{}])[0].get("value", {}).get("contacts", [{}])[0].get("wa_id", "")
        
        # Processa a mensagem recebida
        updated_phone = whatsapp_manager.handle_incoming_message(data)
        
        return jsonify({"status": "ok"}), 200
    except Exception as e:
        logger.error(f"Erro ao processar mensagem do webhook: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/all_conversations', methods=['GET'])
def get_all_conversations():
    try:
        # Retorna apenas os dados de todas as conversas
        return jsonify(whatsapp_manager.conversations), 200
    except Exception as e:
        logger.error(f"Erro ao obter todas as conversas: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/delete_conversation/<phone_number>', methods=['POST'])
def delete_conversation(phone_number):
    try:
        # Verifica se a conversa existe
        if phone_number in whatsapp_manager.conversations:
            # Remove a conversa da memória
            del whatsapp_manager.conversations[phone_number]
            
            # Tenta remover o arquivo do Google Cloud Storage
            try:
                bucket_name = "aerial-acre-455118-a9-conversations"  # Nome do seu bucket
                bucket = storage_client.bucket(bucket_name)
                blob = bucket.blob(f"{phone_number}.json")
                blob.delete()
                logger.info(f"Arquivo de conversa {phone_number}.json removido do GCS")
            except Exception as storage_error:
                logger.warning(f"Erro ao deletar arquivo no GCS: {str(storage_error)}")
            
            logger.info(f"Conversa {phone_number} deletada com sucesso")
            return jsonify({"status": "success"}), 200
        else:
            logger.warning(f"Conversa não encontrada para deletar: {phone_number}")
            return jsonify({"status": "error", "message": "Conversa não encontrada"}), 404
    except Exception as e:
        logger.error(f"Erro ao deletar conversa {phone_number}: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/conversation/<phone_number>', methods=['GET'])
def get_conversation(phone_number):
    try:
        # Verifica se a conversa existe
        if phone_number in whatsapp_manager.conversations:
            # Retorna os dados da conversa
            return jsonify(whatsapp_manager.conversations[phone_number]), 200
        else:
            # Conversa não encontrada
            return jsonify({"status": "error", "message": "Conversa não encontrada"}), 404
    except Exception as e:
        logger.error(f"Erro ao obter conversa {phone_number}: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.after_request
def add_header(response):
    # Adiciona cabeçalhos para evitar cache
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    response.headers["Pragma"] = "no-cache"
    response.headers["Expires"] = "0"
    return response

if __name__ == "__main__":
    @app.route('/debug_media_send', methods=['POST'])
    def debug_media_send():
        try:
            data = request.json
            to_number = data.get("to_number")
            message = data.get("message", "Teste de diagnóstico")
            media_path = data.get("media_path")
            media_type = data.get("media_type", "image")
            
            logger.info(f"DEBUG ROTA: Iniciando teste de envio de mídia para {to_number}")
            logger.info(f"DEBUG ROTA: Mídia: {media_type} - {media_path}")
            
            # Forçar modo humano para teste
            if to_number in whatsapp_manager.conversations:
                original_mode = whatsapp_manager.conversations[to_number].get("mode", "auto")
                whatsapp_manager.conversations[to_number]["mode"] = "human"
                logger.info(f"DEBUG ROTA: Modo original: {original_mode}, alterado para: human")
            
            # Tenta enviar a mensagem
            result = whatsapp_manager.send_message_to_whatsapp(to_number, message, media_type, media_path)
            
            # Restaura o modo original
            if to_number in whatsapp_manager.conversations:
                whatsapp_manager.conversations[to_number]["mode"] = original_mode
                logger.info(f"DEBUG ROTA: Restaurado modo: {original_mode}")
            
            # Retorna o resultado
            return jsonify({
                "status": "success" if result else "error",
                "message": "Mensagem enviada com sucesso" if result else "Falha ao enviar mensagem"
            })
        except Exception as e:
            logger.error(f"DEBUG ROTA ERROR: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return jsonify({"status": "error", "message": str(e)}), 500
    
    logger.info("Iniciando servidor Flask na porta 5000...")

    @app.route('/test_audio_send', methods=['GET'])
    def test_audio_send():
        try:
            # Use um arquivo de áudio de teste que sabemos que existe no GCS
            test_audio_path = "audio/test_audio.ogg"  # Ajuste para um caminho que exista no seu bucket
            test_phone = "5511964648888"  # Ajuste para um número válido
            
            logger.info(f"TESTE DE ÁUDIO: Iniciando teste com {test_audio_path}")
            
            # Teste direto da função de upload de mídia
            mime_type = "audio/ogg"
            media_id = whatsapp_manager.media_handler.upload_media(test_audio_path, whatsapp_manager.WHATSAPP_TOKEN, mime_type)
            
            logger.info(f"TESTE DE ÁUDIO: Resultado do upload: {media_id}")
            
            if not media_id:
                return jsonify({"status": "error", "stage": "upload", "message": "Falha ao fazer upload do áudio"})
            
            # Tenta enviar a mensagem
            result = whatsapp_manager.send_message_to_whatsapp(test_phone, "", "audio", test_audio_path)
            
            logger.info(f"TESTE DE ÁUDIO: Resultado do envio: {result}")
            
            return jsonify({
                "status": "success" if result else "error",
                "stage": "send" if media_id else "upload",
                "media_id": media_id,
                "message": "Teste completo" if result else "Falha no envio"
            })
        except Exception as e:
            logger.error(f"TESTE DE ÁUDIO ERROR: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return jsonify({"status": "error", "message": str(e), "traceback": traceback.format_exc()}), 500

    app.run(debug=True, port=5000)
# FIM DO ARQUIVO: main.py 

// INÍCIO DO ARQUIVO: static\app.js (3/6) 
/** INÍCIO DE app.js
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * Principal módulo da aplicação
 * Contém o objeto global App e funções principais 
 */

// Objeto global que será usado pelos event handlers
window.App = {
    // Estado da aplicação
    currentPhone: null,
    currentConversation: null,
    mediaType: null,
    mediaInfo: null,
    currentLocation: null,
    // Removido lastMessageId
    
    // Métodos iniciais - outros módulos irão extender esse objeto
    init: function() {
        console.log("Inicializando WhatsApp Web Admin");
        // Método init agora está vazio após remoção de setupEventListeners
    },
    
    // Método setupEventListeners foi removido completamente
    
    filterConversations: function() {
        const searchText = document.getElementById('search-input').value.toLowerCase();
        const conversations = document.querySelectorAll('.conversation-item');
        
        conversations.forEach(convo => {
            const name = convo.querySelector('.name').textContent.toLowerCase();
            const phone = convo.querySelector('.phone').textContent.toLowerCase();
            
            if (name.includes(searchText) || phone.includes(searchText)) {
                convo.style.display = 'flex';
            } else {
                convo.style.display = 'none';
            }
        });
    },
    
    startNewConversation: function() {
        const phoneInput = document.getElementById('new-number');
        const phoneNumber = phoneInput.value.trim();
        
        if (!phoneNumber) {
            alert("Digite um número de telefone!");
            return;
        }
        
        // Verifica se a conversa já existe
        const existingConvo = document.querySelector(`.conversation-item[data-phone="${phoneNumber}"]`);
        if (existingConvo) {
            // Se já existe, apenas carrega
            this.loadConversation(phoneNumber);
            phoneInput.value = '';
            return;
        }
        
        // Cria uma nova conversa temporária
        this.currentPhone = phoneNumber;
        
        // Limpa a entrada
        phoneInput.value = '';
        
        // Inicia a conversa (enviando uma mensagem vazia para criar a conversa)
        const messageInput = document.getElementById('message-input');
        messageInput.value = "Olá! Estou iniciando uma nova conversa.";
        
        // Envia a mensagem
        this.sendMessage();
    },

    sendMessage: function() {
        // Bloqueia múltiplos envios
        if (this.isSubmitting) return;
        this.isSubmitting = true;
    
        if (!App.currentPhone) {
            alert("Selecione uma conversa primeiro!");
            this.isSubmitting = false;
            return;
        }
        
        const messageInput = document.getElementById('message-input');
        const message = messageInput.value.trim();
        
        if (!message && !App.mediaInfo) {
            alert("Digite uma mensagem ou selecione uma mídia!");
            this.isSubmitting = false;
            return;
        }
        
        const data = {
            to_number: App.currentPhone,
            message: message
        };
        
        if (App.mediaInfo) {
            data.media_path = App.mediaInfo.path;
            data.media_type = App.mediaInfo.type;
        }
        
        const sendButton = document.getElementById('send-button');
        sendButton.disabled = true;
        
        fetch('/send_message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error("Erro ao enviar mensagem");
            }
            return response.json();
        })
        .then(result => {
            messageInput.value = '';
            App.mediaInfo = null;
            
            // Remove a flag de submissão
            this.isSubmitting = false;
            
            // Substituído por uma recarga manual
            alert("Mensagem enviada. Recarregue a página para ver as atualizações.");
        })
        .catch(error => {
            console.error("Erro:", error);
            alert("Não foi possível enviar a mensagem");
            
            // Remove a flag de submissão em caso de erro
            this.isSubmitting = false;
        })
        .finally(() => {
            sendButton.disabled = false;
        });
    },
    
    confirmDeleteConversation: function(phone) {
        if (confirm("Tem certeza que deseja apagar esta conversa?")) {
            fetch(`/delete_conversation/${phone}`, {
                method: 'POST'
            })
            .then(response => {
                if (!response.ok) {
                    if (response.status === 404) {
                        // Implementação temporária (caso a rota backend não exista ainda)
                        const convoItem = document.querySelector(`.conversation-item[data-phone="${phone}"]`);
                        if (convoItem) convoItem.remove();
                        
                        if (phone === App.currentPhone) {
                            App.currentPhone = null;
                            App.currentConversation = null;
                            document.getElementById('message-area').innerHTML = 
                                '<div class="empty-state">Selecione uma conversa para ver as mensagens</div>';
                            document.getElementById('ai-message-area').innerHTML = 
                                '<div class="empty-state">Informações da IA aparecerão aqui quando uma conversa estiver ativa</div>';
                            document.getElementById('toggle-mode-btn').style.display = 'none';
                            document.getElementById('current-contact-name').textContent = 'Selecione uma conversa';
                            document.getElementById('current-contact-avatar').innerHTML = '<div class="avatar-placeholder">?</div>';
                        }
                        
                        alert("Conversa removida da interface!");
                        return new Promise(resolve => resolve({}));
                    }
                    throw new Error("Erro ao apagar conversa: " + response.statusText);
                }
                return response.json();
            })
            .then(data => {
                if (!data.status || data.status === 'success') {
                    // Remove o elemento da lista
                    const convoItem = document.querySelector(`.conversation-item[data-phone="${phone}"]`);
                    if (convoItem) convoItem.remove();
                    
                    // Se era a conversa atual, limpa a área de mensagens
                    if (phone === App.currentPhone) {
                        App.currentPhone = null;
                        App.currentConversation = null;
                        document.getElementById('message-area').innerHTML = 
                            '<div class="empty-state">Selecione uma conversa para ver as mensagens</div>';
                        document.getElementById('ai-message-area').innerHTML = 
                            '<div class="empty-state">Informações da IA aparecerão aqui quando uma conversa estiver ativa</div>';
                        document.getElementById('toggle-mode-btn').style.display = 'none';
                        document.getElementById('current-contact-name').textContent = 'Selecione uma conversa';
                        document.getElementById('current-contact-avatar').innerHTML = '<div class="avatar-placeholder">?</div>';
                    }
                    
                    // Notificação de sucesso
                    const notification = document.createElement('div');
                    notification.className = 'notification';
                    notification.innerHTML = '<i class="fas fa-check-circle"></i> Conversa apagada com sucesso!';
                    document.body.appendChild(notification);
                    
                    // Remove a notificação após alguns segundos
                    setTimeout(() => {
                        notification.classList.add('fade-out');
                        setTimeout(() => notification.remove(), 500);
                    }, 3000);
                } else {
                    alert("Erro ao apagar conversa: " + (data.message || "Erro desconhecido"));
                }
            })
            .catch(error => {
                console.error("Erro ao apagar conversa:", error);
                alert("Erro ao apagar conversa: " + error.message);
            });
        }
    },
    
    closeModal: function() {
        document.getElementById('media-upload-modal').style.display = 'none';
        
        // Fecha também outros modais que possam estar abertos
        const allModals = document.querySelectorAll('.modal');
        allModals.forEach(modal => {
            if (modal.id !== 'media-upload-modal') {
                modal.remove();
            } else {
                modal.style.display = 'none';
            }
        });
        
        // Limpa menus de comandos
        if(this.hideCommandMenu) {
            this.hideCommandMenu();
        }
    },
    
    // Função para determinar se uma URL é do GCS
    isGcsUrl: function(url) {
        return url && (
            url.includes('storage.googleapis.com') || 
            url.includes('storage.cloud.google.com')
        );
    },
    
    // Função para obter a URL completa (local ou GCS)
    getMediaUrl: function(mediaPath) {
        // Verificar se o caminho é nulo ou vazio
        if (!mediaPath) {
            console.log("Aviso: Caminho de mídia nulo ou vazio");
            return ''; // Retorna uma string vazia para evitar erros
        }
        
        // Se já for uma URL completa do GCS, usa ela diretamente
        if (this.isGcsUrl(mediaPath)) {
            return mediaPath;
        }
        
        // Se for um caminho relativo
        if (typeof mediaPath === 'string') {
            // Verifica se começa com /media/ e remove se necessário
            if (mediaPath.startsWith('/media/')) {
                mediaPath = mediaPath.substring(7);
            }
            
            // Tenta localizar no GCS primeiro
            const bucketName = 'aerial-acre-455118-a9-media';
            return `https://storage.googleapis.com/${bucketName}/${mediaPath}`;
        }
        
        // Fallback para o caminho local
        return `/media/${mediaPath}`;
    },

    // Método simplificado para carregar conversa sem atualização incremental
    loadConversation: function(phone) {
        console.log("Carregando conversa:", phone);
        
        fetch('/conversation/' + phone)
            .then(response => response.json())
            .then(data => {
                // Atualiza informações básicas do contato
                document.getElementById('current-contact-name').textContent = data.name || "Cliente";
                
                // Atualiza avatar do contato
                const contactAvatar = document.getElementById('current-contact-avatar');
                const newAvatarHtml = data.profile_pic 
                    ? `<img src="${this.getMediaUrl(data.profile_pic)}" alt="${data.name || 'Cliente'}">` 
                    : `<div class="avatar-placeholder">${((data.name || 'Cliente')[0] || '?').toUpperCase()}</div>`;
                
                contactAvatar.innerHTML = newAvatarHtml;
                
                // Área de mensagens
                const messageArea = document.getElementById('message-area');
                
                // Caso não tenha mensagens
                if (!data.messages || data.messages.length === 0) {
                    messageArea.innerHTML = '<div class="empty-state">Nenhuma mensagem encontrada</div>';
                    document.getElementById('ai-message-area').innerHTML = 
                        '<div class="empty-state">Nenhuma interação com a IA ainda</div>';
                    return;
                }
                
                // Carregamento completo sem considerar atualização incremental
                messageArea.innerHTML = '';
                data.messages.forEach(msg => {
                    const messageElement = this.createMessageElement(msg);
                    messageArea.appendChild(messageElement);
                });
                
                // Rola para a última mensagem
                messageArea.scrollTop = messageArea.scrollHeight;
                
                // Área de mensagens da IA
                const aiMessageArea = document.getElementById('ai-message-area');
                const aiInteractions = data.messages.filter(msg => 
                    msg.from === 'cliente' || msg.from === 'qwen' || msg.from === 'deepseek'
                );
                
                if (!aiInteractions || aiInteractions.length === 0) {
                    aiMessageArea.innerHTML = '<div class="empty-state">Nenhuma interação com a IA ainda</div>';
                } else {
                    aiMessageArea.innerHTML = '';
                    aiInteractions.forEach(msg => {
                        const messageElement = this.createAIMessageElement(msg);
                        aiMessageArea.appendChild(messageElement);
                    });
                    
                    // Rola para a última mensagem da IA
                    aiMessageArea.scrollTop = aiMessageArea.scrollHeight;
                }
                
                // Atualiza o estado da aplicação
                this.currentPhone = phone;
                this.currentConversation = data;
                
                // Atualiza o botão de modo
                const modeButton = document.getElementById('toggle-mode-btn');
                modeButton.style.display = 'inline-block';
                modeButton.className = data.mode === 'human' ? 'human-mode' : 'auto-mode';
                modeButton.innerHTML = data.mode === 'human' ? 
                    '<i class="fas fa-user"></i> Modo Humano' : 
                    '<i class="fas fa-robot"></i> Modo Automático';
                
                // Marca a conversa ativa na lista
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.getAttribute('data-phone') === phone) {
                        item.classList.add('active');
                    }
                });
                
                // Removida verificação de novas mensagens
            })
            .catch(error => {
                console.error("Erro ao carregar conversa:", error);
                alert("Erro ao carregar conversa: " + error.message);
            });
    },

    // Método auxiliar para criar elemento de mensagem
    createMessageElement: function(msg) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${msg.from}`;
        messageElement.dataset.messageId = msg.id;
        
        // Conteúdo da mensagem
        let content = '';
        switch(msg.type) {
            case 'text':
                content = `<div class="message-text">${msg.content}</div>`;
                break;
            case 'image':
                const imageUrl = this.getMediaUrl(msg.media_url);
                content = `
                    <div class="message-media">
                        <img src="${imageUrl}" alt="Imagem" onclick="App.zoomImage('${imageUrl}')">
                    </div>
                    ${msg.content ? `<div class="message-caption">${msg.content}</div>` : ''}
                `;
                break;
            case 'audio':
                const audioUrl = this.getMediaUrl(msg.media_url);
                content = `
                    <div class="message-media">
                        <audio controls src="${audioUrl}"></audio>
                    </div>
                    ${msg.content ? `<div class="message-caption">${msg.content}</div>` : ''}
                `;
                break;
            case 'video':
                const videoUrl = this.getMediaUrl(msg.media_url);
                content = `
                    <div class="message-media">
                        <video controls src="${videoUrl}"></video>
                    </div>
                    ${msg.content ? `<div class="message-caption">${msg.content}</div>` : ''}
                `;
                break;
            case 'document':
                const docUrl = this.getMediaUrl(msg.media_url);
                const fileName = msg.media_url.split('/').pop();
                content = `
                    <div class="message-document">
                        <a href="${docUrl}" class="document-link" target="_blank">
                            <i class="fas fa-file"></i> ${fileName}
                        </a>
                    </div>
                    ${msg.content ? `<div class="message-caption">${msg.content}</div>` : ''}
                `;
                break;
            case 'location':
                content = `
                    <div class="message-location">
                        <img src="https://maps.googleapis.com/maps/api/staticmap?center=${msg.latitude},${msg.longitude}&zoom=13&size=300x150&markers=color:red%7C${msg.latitude},${msg.longitude}" 
                          alt="Localização" onclick="App.openLocation(${msg.latitude}, ${msg.longitude})">
                        <div class="location-caption">
                            <i class="fas fa-map-marker-alt"></i> Localização
                        </div>
                    </div>
                `;
                break;
        }
        
        // Adiciona opções de mensagem
        messageElement.innerHTML = `
            <div class="message-options">
                <button class="options-btn" onclick="App.showMessageOptions(event, '${msg.id || ''}')">
                    <i class="fas fa-ellipsis-v"></i>
                </button>
            </div>
            ${content}
            <div class="message-time">${msg.timestamp || ''}</div>
        `;
        
        return messageElement;
    },

    // Método auxiliar para criar elemento de mensagem da IA
    createAIMessageElement: function(msg) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${msg.from}`;
        // Conteúdo da mensagem simplificado
        let content = msg.type === 'text' 
            ? `<div class="message-text">${msg.content}</div>` 
            : `<div class="message-text">[${msg.type.toUpperCase()}] ${msg.content || ''}</div>`;

        messageElement.innerHTML = `
            ${content}
            <div class="message-time">${msg.timestamp || ''}</div>
        `;

        return messageElement;
    },

}; // <-- Este fecha o objeto App

// Todos os event listeners foram removidos
// FIM DO ARQUIVO: static\app.js 

// INÍCIO DO ARQUIVO: static\conversation.js (4/6) 
    /** conversation.js
     * Módulo para gerenciamento de conversas
     * Funções para carregar, enviar mensagens e gerenciar o estado das conversas
     */

    // Extende o objeto App com as funções de conversas
    (function(App) {
        
        // Função para determinar se uma URL é do GCS (NOVO)
        App.isGcsUrl = function(url) {
            return url && (
                url.includes('storage.googleapis.com') || 
                url.includes('storage.cloud.google.com')
            );
        };
        
        // Função para obter a URL completa (local ou GCS) (MODIFICADA)
        App.getMediaUrl = function(mediaPath) {
            // Verificar se o caminho é nulo ou vazio
            if (!mediaPath) {
                console.log("Aviso: Caminho de mídia nulo ou vazio");
                return ''; // Retorna uma string vazia para evitar erros
            }
            
            // Se já for uma URL completa do GCS, usa ela diretamente
            if (App.isGcsUrl(mediaPath)) {
                return mediaPath;
            }
            
            // Se for um caminho relativo
            if (typeof mediaPath === 'string') {
                // Verifica se começa com /media/ e remove se necessário
                if (mediaPath.startsWith('/media/')) {
                    mediaPath = mediaPath.substring(7);
                }
                
                // Tenta localizar no GCS primeiro
                const bucketName = 'aerial-acre-455118-a9-media';
                return `https://storage.googleapis.com/${bucketName}/${mediaPath}`;
            }
            
            // Fallback para o caminho local
            return `/media/${mediaPath}`;
        };
        

            // Método para alternar entre os modos automático e humano
App.toggleMode = function() {
    if (!App.currentPhone) {
        alert("Selecione uma conversa primeiro!");
        return;
    }
    
    // Desabilita o botão durante a requisição
    const toggleButton = document.getElementById('toggle-mode-btn');
    toggleButton.disabled = true;
    
    fetch(`/toggle_mode/${App.currentPhone}`, {
        method: 'POST'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error("Erro ao alternar o modo da conversa");
        }
        return response.json();
    })
    .then(data => {
        if (data.status === 'success') {
            // Atualiza o botão com o novo modo
            const newMode = data.mode;
            
            // Atualiza a interface
            toggleButton.className = newMode === 'human' ? 'human-mode' : 'auto-mode';
            toggleButton.innerHTML = newMode === 'human' ? 
                '<i class="fas fa-user"></i> Modo Humano' : 
                '<i class="fas fa-robot"></i> Modo Automático';
                
            // Atualiza também o ícone na lista de conversas
            const conversationToggle = document.querySelector(`.conversation-item[data-phone="${App.currentPhone}"] .mode-toggle`);
            if (conversationToggle) {
                conversationToggle.className = `mode-toggle ${newMode === 'human' ? 'human-mode' : 'auto-mode'}`;
                conversationToggle.innerHTML = `<i class="fas ${newMode === 'human' ? 'fa-user' : 'fa-robot'}"></i>`;
            }
            
            // Atualiza o estado da conversa atual
            if (App.currentConversation) {
                App.currentConversation.mode = newMode;
            }
            
            console.log(`Modo da conversa alterado para: ${newMode}`);
        } else {
            alert("Erro ao alternar o modo: " + (data.message || "Erro desconhecido"));
        }
    })
    .catch(error => {
        console.error("Erro ao alternar o modo:", error);
        alert("Erro ao alternar o modo: " + error.message);
    })
    .finally(() => {
        toggleButton.disabled = false;
    });
};



        // Envia uma mensagem para um contato
        App.sendMessage = function() {
            // Bloqueia múltiplos envios
            if (this.isSubmitting) return;
            this.isSubmitting = true;
        
            if (!App.currentPhone) {
                alert("Selecione uma conversa primeiro!");
                this.isSubmitting = false;
                return;
            }
            
            const messageInput = document.getElementById('message-input');
            const message = messageInput.value.trim();
            
            if (!message && !App.mediaInfo) {
                alert("Digite uma mensagem ou selecione uma mídia!");
                this.isSubmitting = false;
                return;
            }
            
            const data = {
                to_number: App.currentPhone,
                message: message
            };
            
            if (App.mediaInfo) {
                data.media_path = App.mediaInfo.path;
                data.media_type = App.mediaInfo.type;
            }
            
            const sendButton = document.getElementById('send-button');
            sendButton.disabled = true;
            
            // Feedback visual imediato
            this.addTemporaryMessage(message, App.mediaInfo);
            messageInput.value = '';
            
            fetch('/send_message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error("Erro ao enviar mensagem");
                }
                return response.json();
            })
            .then(result => {
                // Limpa a mídia após envio
                App.mediaInfo = null;
                
                // Força atualização imediata da conversa
                App.loadConversation(App.currentPhone, true);
                
                // Remove mensagens temporárias (caso ainda existam)
                document.querySelectorAll('.temp-message').forEach(el => el.remove());
            })
            .catch(error => {
                console.error("Erro:", error);
                alert("Não foi possível enviar a mensagem");
                
                // Remove mensagens temporárias em caso de erro
                document.querySelectorAll('.temp-message').forEach(el => el.remove());
                
                // Restaura a mensagem não enviada
                messageInput.value = message;
            })
            .finally(() => {
                this.isSubmitting = false;
                sendButton.disabled = false;
            });
        };
        

        
        // Envia uma localização para um contato
        App.sendLocation = function(lat, lng) {
            if (!App.currentPhone) return;
            
            // Desabilita o botão durante o envio
            const sendButton = document.getElementById('send-button');
            sendButton.disabled = true;
            
            // Adiciona mensagem temporária na interface para feedback imediato
            const messageArea = document.getElementById('message-area');
            const tempMsg = document.createElement('div');
            tempMsg.className = 'message vendedor temp-message';
            tempMsg.innerHTML = `
                <div class="message-location">
                    <img src="https://maps.googleapis.com/maps/api/staticmap?center=${lat},${lng}&zoom=13&size=300x150&markers=color:red%7C${lat},${lng}" 
                        alt="Localização" onclick="App.openLocation(${lat}, ${lng})">
                    <div class="location-caption">
                        <i class="fas fa-map-marker-alt"></i> Localização Compartilhada
                    </div>
                </div>
                <div class="message-time">Enviando...</div>
            `;
            messageArea.appendChild(tempMsg);
            messageArea.scrollTop = messageArea.scrollHeight;
            
            // Envia a requisição para o backend
            fetch('/send_location', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    to_number: App.currentPhone,
                    latitude: lat,
                    longitude: lng
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error("Erro ao enviar localização: " + response.statusText);
                }
                return response.json();
            })
            .then(result => {
                if (result.status === 'success') {
                    // Remove a mensagem temporária
                    tempMsg.remove();
                } else {
                    // Mostra erro e remove a mensagem temporária
                    tempMsg.remove();
                    alert("Erro ao enviar localização: " + (result.message || "Erro desconhecido"));
                }
            })
            .catch(error => {
                // Mostra erro e remove a mensagem temporária
                tempMsg.remove();
                console.error("Erro ao enviar localização:", error);
                alert("Erro ao enviar localização: " + error.message);
            })
            .finally(() => {
                sendButton.disabled = false;
                // Limpa a localização armazenada
                App.currentLocation = null;
            });
        };
        
        // Abre uma localização no Google Maps
        App.openLocation = function(lat, lng) {
            // Abre a localização no Google Maps em uma nova aba
            window.open(`https://www.google.com/maps?q=${lat},${lng}`, '_blank');
        };
        
        // Exibe detalhes do perfil
        App.showProfileDetails = function() {
            if (!App.currentPhone || !App.currentConversation) return;
            
            const profile = App.currentConversation;
            const profilePic = profile.profile_pic || '';
            const name = profile.name || 'Cliente';
            const about = profile.about || 'Disponível'; // Campo a ser adicionado no backend
            
            // Cria um modal de perfil
            const modal = document.createElement('div');
            modal.className = 'modal profile-modal';
            modal.style.display = 'block';
            
            modal.innerHTML = `
                <div class="modal-content profile-content">
                    <span class="close" onclick="App.closeModal()">&times;</span>
                    <div class="profile-header">
                        <div class="profile-image">
                            ${profilePic ? 
                            `<img src="${profilePic}" alt="${name}" onclick="App.zoomImage('${profilePic}')">` : 
                            `<div class="avatar-placeholder large">${name[0].toUpperCase()}</div>`}
                        </div>
                        <h2>${name}</h2>
                        <p class="profile-about">${about}</p>
                    </div>
                    <div class="profile-info">
                        <div class="info-item">
                            <i class="fas fa-phone"></i>
                            <span>${App.currentPhone}</span>
                        </div>
                        <div class="info-item">
                            <i class="fas fa-bell"></i>
                            <span>Notificações: Ativadas</span>
                            <div class="toggle-switch">
                                <input type="checkbox" id="notification-toggle" checked>
                                <label for="notification-toggle"></label>
                            </div>
                        </div>
                        <div class="danger-zone">
                            <button class="danger-btn" onclick="App.confirmDeleteConversation('${App.currentPhone}'); App.closeModal();">
                                <i class="fas fa-trash"></i> Apagar Conversa
                            </button>
                            <button class="block-btn" onclick="alert('Funcionalidade de bloqueio será implementada em breve!')">
                                <i class="fas fa-ban"></i> Bloquear Contato
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Fecha o modal se clicar fora do conteúdo
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    App.closeModal();
                }
            });
        };

        // Exibe uma imagem em tamanho maior
        App.zoomImage = function(imageUrl) {
            // MODIFICADO: Usa a função getMediaUrl para garantir URL correta
            imageUrl = App.getMediaUrl(imageUrl);
            
            // Cria um modal para mostrar a imagem ampliada
            const modal = document.createElement('div');
            modal.className = 'modal zoom-modal';
            modal.innerHTML = `
                <div class="modal-content image-zoom">
                    <span class="close" onclick="App.closeModal()">&times;</span>
                    <img src="${imageUrl}" alt="Imagem ampliada">
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.style.display = 'block';
            
            // Fecha o modal ao clicar fora da imagem
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    App.closeModal();
                }
            });
        };
        
        // Funções para gerenciar opções de mensagens
        App.showMessageOptions = function(event, messageId) {
            event.stopPropagation();
            
            // Remove qualquer menu de opções existente
            const existingMenu = document.getElementById('message-options-menu');
            if (existingMenu) existingMenu.remove();
            
            // Cria o menu de opções
            const optionsMenu = document.createElement('div');
            optionsMenu.id = 'message-options-menu';
            optionsMenu.className = 'options-menu';
            optionsMenu.innerHTML = `
                <div class="option" onclick="App.replyToMessage('${messageId}')">
                    <i class="fas fa-reply"></i> Responder
                </div>
                <div class="option" onclick="App.forwardMessage('${messageId}')">
                    <i class="fas fa-share"></i> Encaminhar
                </div>
                <div class="option" onclick="App.copyMessageText('${messageId}')">
                    <i class="fas fa-copy"></i> Copiar
                </div>
                <div class="option delete" onclick="App.deleteMessage('${messageId}')">
                    <i class="fas fa-trash"></i> Apagar
                </div>
            `;
            
            // Posiciona o menu próximo ao botão de opções
            const button = event.currentTarget;
            const rect = button.getBoundingClientRect();
            
            optionsMenu.style.top = `${rect.bottom + window.scrollY}px`;
            optionsMenu.style.left = `${rect.left + window.scrollX - 120}px`;
            
            document.body.appendChild(optionsMenu);
            
            // Fecha o menu se clicar fora dele
            document.addEventListener('click', function closeMenu(e) {
                if (!optionsMenu.contains(e.target) && e.target !== button) {
                    optionsMenu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            });
        };
        
        App.replyToMessage = function(messageId) {
            // Implementação futura para responder a mensagens específicas
            alert("Função de responder será implementada em breve!");
            document.getElementById('message-options-menu')?.remove();
        };
        
        App.forwardMessage = function(messageId) {
            // Implementação futura para encaminhar mensagens
            alert("Função de encaminhar será implementada em breve!");
            document.getElementById('message-options-menu')?.remove();
        };
        
        App.copyMessageText = function(messageId) {
            // Copia o texto da mensagem para a área de transferência
            const message = document.querySelector(`.message`);
            const textElement = message?.querySelector('.message-text');
            
            if (textElement) {
                const text = textElement.textContent;
                navigator.clipboard.writeText(text)
                    .then(() => {
                        // Feedback visual
                        const notification = document.createElement('div');
                        notification.className = 'notification';
                        notification.innerHTML = '<i class="fas fa-check-circle"></i> Texto copiado!';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            notification.classList.add('fade-out');
                            setTimeout(() => notification.remove(), 500);
                        }, 1500);
                    })
                    .catch(err => {
                        console.error('Erro ao copiar texto: ', err);
                        alert('Não foi possível copiar o texto: ' + err);
                    });
            }
            
            document.getElementById('message-options-menu')?.remove();
        };
        
        App.deleteMessage = function(messageId) {
            if (confirm("Tem certeza que deseja apagar esta mensagem?")) {
                // Implementação temporária - remove visualmente o elemento até que o backend seja implementado
                const message = document.querySelector(`.message`);
                if (message) {
                    message.classList.add('deleted');
                    setTimeout(() => {
                        message.innerHTML = '<div class="deleted-message"><i class="fas fa-ban"></i> Mensagem apagada</div>';
                    }, 300);
                }
                
                // Implementação futura para deletar do backend
                // fetch(`/delete_message/${messageId}`, {
                //     method: 'POST'
                // }).then(/* ... */);
            }
            
            document.getElementById('message-options-menu')?.remove();
        };
        // Adicione esta função ao conversation.js no objeto App

        App.debugMediaSend = function() {
            if (!App.currentPhone || !App.mediaInfo) {
                console.error("Não há conversa ativa ou mídia selecionada");
                return;
            }
            
            console.log("Enviando requisição de diagnóstico para o servidor");
            console.log("Mídia:", App.mediaInfo);
            
            fetch('/debug_media_send', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    to_number: App.currentPhone,
                    message: "Teste de diagnóstico",
                    media_path: App.mediaInfo.path,
                    media_type: App.mediaInfo.type
                })
            })
            .then(response => response.json())
            .then(result => {
                console.log("Resposta do diagnóstico:", result);
                alert("Resultado do diagnóstico: " + (result.status === "success" ? "Sucesso!" : "Falha") + 
                    "\nDetalhes: " + result.message);
            })
            .catch(error => {
                console.error("Erro no diagnóstico:", error);
                alert("Erro no diagnóstico: " + 
                    error.message);
            });
        };
        // Função para atualizar apenas as mensagens
// Função para atualizar as mensagens da conversa atual

// Função para selecionar uma mensagem
App.selectMessage = function(element) {
    // Remove seleção anterior
    document.querySelectorAll('.message.selected').forEach(msg => {
        msg.classList.remove('selected');
    });
    
    // Adiciona seleção à mensagem clicada
    element.classList.add('selected');
};
    })(window.App || (window.App = {}));
// FIM DO ARQUIVO: static\conversation.js 

// INÍCIO DO ARQUIVO: static\ui.js (5/6) 
/**
 * Módulo para gerenciamento de interface
 * Funções para manipulação de elementos UI, modais, etc.
 */

// Extende o objeto App com as funções de UI
(function(App) {
    
    // Inicializa a aplicação
    App.init = function() {
        console.log("Inicializando aplicação...");
        
        // Configura o evento de tecla nos campos de mensagem
        const messageInput = document.getElementById('message-input');
        if (messageInput) {
            messageInput.addEventListener('keydown', function(e) {
                // Envia ao pressionar Enter (sem Shift)
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    App.sendMessage();
                }
                
                // Exibe o menu de comandos ao digitar / (e não tiver nada antes)
                if (e.key === '/' && this.selectionStart === 0) {
                    App.showCommandMenu();
                }
            });
            
            // Monitora a digitação para ocultar o menu de comandos se necessário
            messageInput.addEventListener('input', function() {
                if (this.value.length > 0 && !this.value.startsWith('/')) {
                    App.hideCommandMenu();
                }
            });
        }
        
        

        
        // Adicionamos um handler para o evento beforeunload para limpar recursos
        window.addEventListener('beforeunload', function() {
            // Limpa qualquer stream de áudio ou gravação em andamento
            App.stopAudioStream && App.stopAudioStream();
            
            // Limpa timers e intervalos
            clearInterval(App.recordingTimer);
        });
    };
    

    
    // Fecha qualquer modal aberto
    App.closeModal = function() {
        document.querySelectorAll('.modal').forEach(function(modal) {
            modal.style.display = 'none';
        });
        
        // Limpa recursos ao fechar modais
        if (App.isRecording) {
            App.stopRecording && App.stopRecording();
        }
        App.stopAudioStream && App.stopAudioStream();
    };
    
    // Filtra conversas com base na pesquisa
    App.filterConversations = function() {
        const searchText = document.getElementById('search-input').value.toLowerCase();
        const conversations = document.querySelectorAll('.conversation-item');
        
        conversations.forEach(function(item) {
            const name = item.querySelector('.name').textContent.toLowerCase();
            const phone = item.getAttribute('data-phone').toLowerCase();
            
            // Se o texto estiver contido no nome ou telefone, mostra o item
            if (name.includes(searchText) || phone.includes(searchText)) {
                item.style.display = 'flex';
            } else {
                item.style.display = 'none';
            }
        });
    };
    
    // Inicia uma nova conversa com um número de telefone
    App.startNewConversation = function() {
        const phoneInput = document.getElementById('new-number');
        let phone = phoneInput.value.trim();
        
        if (!phone) {
            alert("Digite um número de telefone!");
            return;
        }
        
        // Remove caracteres não numéricos
        phone = phone.replace(/\D/g, '');
        
        // Verifica se é um número válido (mais de 8 dígitos)
        if (phone.length < 8) {
            alert("Número de telefone inválido!");
            return;
        }
        
        // Verifica se já existe um elemento para este número
        const existingConversation = document.querySelector(`.conversation-item[data-phone="${phone}"]`);
        if (existingConversation) {
            // Se já existir, apenas carrega a conversa
            App.loadConversation(phone);
            
            // Limpa o campo de entrada
            phoneInput.value = '';
            
            return;
        }
        
        // Cria um novo elemento na lista de conversas
        const newConversation = document.createElement('div');
        newConversation.className = 'conversation-item';
        newConversation.setAttribute('data-phone', phone);
        newConversation.onclick = function() { App.loadConversation(phone); };
        
        newConversation.innerHTML = `
            <div class="conversation-avatar">
                <div class="avatar-placeholder">?</div>
            </div>
            <div class="conversation-info">
                <div class="name">Novo Contato</div>
                <div class="phone">${phone}</div>
            </div>
            <div class="conversation-actions-hover">
                <button class="action-btn delete-btn" onclick="event.stopPropagation(); App.confirmDeleteConversation('${phone}')">
                    <i class="fas fa-trash"></i>
                </button>
                <button class="action-btn archive-btn" onclick="event.stopPropagation(); alert('Função de arquivar será implementada em breve!')">
                    <i class="fas fa-archive"></i>
                </button>
            </div>
            <div class="conversation-mode">
                <div class="mode-toggle auto-mode" onclick="event.stopPropagation(); App.toggleMode()">
                    <i class="fas fa-robot"></i>
                </div>
            </div>
        `;
        
        // Adiciona o novo elemento à lista
        const conversationList = document.getElementById('conversation-list');
        conversationList.prepend(newConversation);
        
        // Carrega a conversa
        App.loadConversation(phone);
        
        // Limpa o campo de entrada
        phoneInput.value = '';
    };
    
    // Confirmação para deletar uma conversa
    App.confirmDeleteConversation = function(phone) {
        if (confirm(`Tem certeza que deseja apagar a conversa com ${phone}?`)) {
            App.deleteConversation(phone);
        }
    };
    
    // Deleta uma conversa
    App.deleteConversation = function(phone) {
        // Envia a requisição para o backend
        fetch(`/delete_conversation/${phone}`, {
            method: 'POST'
        })
        .then(response => {
            if (!response.ok) {
                throw new Error("Erro ao deletar conversa: " + response.statusText);
            }
            return response.json();
        })
        .then(result => {
            if (result.status === 'success') {
                // Remove o elemento da lista
                const conversationElement = document.querySelector(`.conversation-item[data-phone="${phone}"]`);
                if (conversationElement) {
                    conversationElement.remove();
                }
                
                // Se era a conversa atual, limpa a área de mensagens
                if (App.currentPhone === phone) {
                    App.currentPhone = null;
                    App.currentConversation = null;
                    
                    // Reseta o cabeçalho
                    document.getElementById('current-contact-name').textContent = 'Selecione uma conversa';
                    document.getElementById('current-contact-avatar').innerHTML = '<div class="avatar-placeholder">?</div>';
                    
                    // Limpa a área de mensagens
                    document.getElementById('message-area').innerHTML = '<div class="empty-state">Selecione uma conversa para ver as mensagens</div>';
                    document.getElementById('ai-message-area').innerHTML = '<div class="empty-state">Informações da IA aparecerão aqui quando uma conversa estiver ativa</div>';
                    
                    // Esconde o botão de modo
                    document.getElementById('toggle-mode-btn').style.display = 'none';
                }
                
                alert("Conversa deletada com sucesso!");
            } else {
                alert("Erro ao deletar conversa: " + (result.message || "Erro desconhecido"));
            }
        })
        .catch(error => {
            console.error("Erro ao deletar conversa:", error);
            alert("Erro ao deletar conversa: " + error.message);
        });
    };
    
    // Detecta se o navegador é mobile
    App.isMobile = function() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    };
    
    // Inicializa a aplicação quando o DOM estiver carregado
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', App.init);
    } else {
        App.init();
    }
    
})(window.App || (window.App = {}));
// FIM DO ARQUIVO: static\ui.js 

<!-- INÍCIO DO ARQUIVO: templates\index.html (6/6) -->
    <!DOCTYPE html>
    <html lang="pt-BR">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>WhatsApp - MP Tintas </title>

        <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

        <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">

        <script src="https://cdn.jsdelivr.net/npm/opus-recorder@8.0.3/dist/recorder.min.js"></script>
        
        <!-- Scripts modulares -->
        <!-- No final, antes do fechamento da tag </body>, adicione: -->

        <script src="{{ url_for('static', filename='app.js') }}" defer></script>
        <script src="{{ url_for('static', filename='conversation.js') }}" defer></script>
        <script src="{{ url_for('static', filename='commands.js') }}" defer></script>
        <script src="{{ url_for('static', filename='media.js') }}" defer></script>
        <script src="{{ url_for('static', filename='ui.js') }}" defer></script>
    </head>
    <body>


    <div class="container">
        <!-- Coluna da esquerda (Lista de Conversas) -->
        <div class="left-column">
            <div class="search-bar">
                <input type="text" id="search-input" placeholder="Buscar conversas..." oninput="App.filterConversations()">
            </div>
            <div class="new-conversation">
                <input type="text" id="new-number" placeholder="Digite o número do WhatsApp">
                <button onclick="App.startNewConversation()">Iniciar Conversa</button>
            </div>
            <div class="conversation-list" id="conversation-list">
                {% for phone, conv in conversations.items() %}
                <div class="conversation-item" data-phone="{{ phone }}" onclick="App.loadConversation('{{ phone }}')">
                    <div class="conversation-avatar">
                        {% if conv.profile_pic %}
                            <img src="{{ conv.profile_pic }}" alt="{{ conv.name }}">
                        {% else %}
                            <div class="avatar-placeholder">{{ conv.name[0]|upper }}</div>
                        {% endif %}
                    </div>
                    <div class="conversation-info">
                        <div class="name">{{ conv.name }}</div>
                        <div class="phone">{{ phone }}</div>
                    </div>
                    <div class="conversation-actions-hover">
                        <button class="action-btn delete-btn" onclick="event.stopPropagation(); App.confirmDeleteConversation('{{ phone }}')">
                            <i class="fas fa-trash"></i>
                        </button>
                        <button class="action-btn archive-btn" onclick="event.stopPropagation(); alert('Função de arquivar será implementada em breve!')">
                            <i class="fas fa-archive"></i>
                        </button>
                    </div>
                    <div class="conversation-mode">
                        <div class="mode-toggle {% if conv.mode == 'human' %}human-mode{% else %}auto-mode{% endif %}" 
                                onclick="event.stopPropagation(); App.toggleMode()">
                            <i class="fas {% if conv.mode == 'human' %}fa-user{% else %}fa-robot{% endif %}"></i>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
        
        <!-- Coluna central (Conversa Atual) -->
        <div class="center-column">
            <div class="header">
                <div class="contact-info" onclick="App.showProfileDetails()">
                    <div class="contact-avatar" id="current-contact-avatar">
                        <div class="avatar-placeholder">?</div>
                    </div>
                    <div class="contact-name" id="current-contact-name">Selecione uma conversa</div>
                </div>
                <div class="conversation-actions">
                    <button id="toggle-mode-btn" onclick="App.toggleMode()" style="display:none;">
                        <i class="fas fa-robot"></i> Modo Automático
                    </button>
                </div>
            </div>
            <div class="message-area" id="message-area">
                <div class="empty-state">
                    Selecione uma conversa para ver as mensagens
                </div>
            </div>
            <div class="input-area">
                <div class="media-buttons">
                    <button type="button" class="media-btn" onclick="App.openMediaUpload('image')">
                        <i class="fas fa-image"></i>
                    </button>
                    <button type="button" class="media-btn" onclick="App.openMediaUpload('audio')">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button type="button" class="media-btn" onclick="App.openMediaUpload('video')">
                        <i class="fas fa-video"></i>
                    </button>
                    <button type="button" class="media-btn" onclick="App.openMediaUpload('document')">
                        <i class="fas fa-file"></i>
                    </button>
                </div>
                <textarea id="message-input" placeholder="Digite uma mensagem ou use / para comandos"></textarea>
                <button type="button" id="send-button" onclick="App.sendMessage()">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
        
        <!-- Coluna da direita (Visualização da IA) -->
        <div class="right-column">
            <div class="header">
                <div class="ai-title">Visão de I.A.</div>
            </div>
            <div class="ai-message-area" id="ai-message-area">
                <div class="empty-state">
                    Informações da IA aparecerão aqui quando uma conversa estiver ativa
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Upload de Mídia -->
    <div id="media-upload-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="App.closeModal()">&times;</span>
            <h3 id="upload-title">Enviar Mídia</h3>
            <form id="media-upload-form">
                <input type="file" id="media-file" name="file">
                <textarea id="media-caption" placeholder="Adicionar legenda (opcional)..."></textarea>
                <button type="button" id="upload-media-btn" onclick="App.uploadMedia()">Enviar</button>
            </form>
        </div>
    </div>

    <!-- No final do seu arquivo templates/index.html -->
<script src="{{ url_for('static', filename='sse_handler.js') }}"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Inicializa o SSE Handler quando a página carrega
        window.sseHandler = new SSEMessageHandler();
        sseHandler.connect();
        
        // Fecha a conexão quando a página é descarregada
        window.addEventListener('beforeunload', () => {
            sseHandler.disconnect();
        });
    });
</script>
    </body>
    </html>
<!-- FIM DO ARQUIVO: templates\index.html -->



#### INÍCIO DO ARQUIVO realtime_service.py


# realtime_service.py
import json
import time
import uuid
import threading
import atexit
from datetime import datetime
from queue import Queue, Empty
from flask import Response, request, jsonify, stream_with_context

class SSEClient:
    """Representa um cliente conectado via SSE"""
    def __init__(self, client_id, response=None):
        self.client_id = client_id
        self.response = response
        self.phone_number = None  # Conversa que o cliente está visualizando
        self.last_event_id = 0
        self.connected_at = datetime.now()
        self.queue = Queue()  # Fila de eventos para este cliente
        
    def set_phone_number(self, phone_number):
        """Define qual número de telefone o cliente está observando"""
        self.phone_number = phone_number
        
    def send_event(self, event_type, data, event_id=None):
        """Envia um evento SSE para este cliente"""
        if event_id is None:
            self.last_event_id += 1
            event_id = self.last_event_id
            
        event = {
            "id": event_id,
            "type": event_type,
            "data": data
        }
        
        # Adiciona à fila do cliente para ser processado pelo stream
        self.queue.put(event)
        return True


class RealtimeService:
    """Gerenciador de comunicação em tempo real via SSE"""
    def __init__(self):
        self.clients = {}  # Mapeamento de client_id para objeto SSEClient
        self.client_lock = threading.RLock()  # Para acesso thread-safe
        self.event_queue = Queue()  # Fila de eventos a serem processados
        self.event_thread = None  # Thread para processamento de eventos
        self.running = False
        self.client_phones = {}  # Mapeamento de phone_number para lista de client_ids
        
    def start(self):
        """Inicia o serviço de eventos em tempo real"""
        if self.running:
            return
            
        self.running = True
        self.event_thread = threading.Thread(target=self._process_event_queue)
        self.event_thread.daemon = True
        self.event_thread.start()
        print("Serviço de eventos em tempo real iniciado")
        
    def stop(self):
        """Para o serviço de eventos em tempo real"""
        self.running = False
        if self.event_thread:
            self.event_thread.join(timeout=5.0)
        print("Serviço de eventos em tempo real parado")
            
    def _process_event_queue(self):
        """Processa a fila de eventos em background"""
        while self.running:
            try:
                event = self.event_queue.get(timeout=1.0)
                self._distribute_event(event)
                self.event_queue.task_done()
            except Empty:
                continue
            except Exception as e:
                print(f"Erro ao processar evento: {str(e)}")
                
    def _distribute_event(self, event):
        """Distribui um evento para os clientes apropriados"""
        event_type = event.get("type")
        event_data = event.get("data")
        target_phone = event.get("phone_number")
        
        with self.client_lock:
            # Se temos um telefone alvo, enviamos apenas para clientes observando esse número
            if target_phone:
                client_ids = self.client_phones.get(target_phone, [])
                for client_id in client_ids:
                    if client_id in self.clients:
                        try:
                            self.clients[client_id].send_event(event_type, event_data)
                        except Exception as e:
                            print(f"Erro ao enviar evento para cliente {client_id}: {str(e)}")
            else:
                # Broadcast para todos os clientes
                for client_id, client in list(self.clients.items()):
                    try:
                        client.send_event(event_type, event_data)
                    except Exception as e:
                        print(f"Erro ao enviar evento para cliente {client_id}: {str(e)}")
                        # Remove cliente com erro
                        self.clients.pop(client_id, None)
                    
    def register_client(self, client_id):
        """Registra um novo cliente SSE"""
        with self.client_lock:
            # Se o cliente já existe, mantém a mesma instância
            if client_id in self.clients:
                return self.clients[client_id]
                
            client = SSEClient(client_id)
            self.clients[client_id] = client
            print(f"Cliente {client_id} registrado")
            return client
            
    def unregister_client(self, client_id):
        """Remove um cliente SSE"""
        with self.client_lock:
            if client_id in self.clients:
                client = self.clients[client_id]
                
                # Remove do mapeamento de telefones
                if client.phone_number and client.phone_number in self.client_phones:
                    if client_id in self.client_phones[client.phone_number]:
                        self.client_phones[client.phone_number].remove(client_id)
                        
                # Remove do dicionário de clientes
                self.clients.pop(client_id, None)
                print(f"Cliente {client_id} removido")
            
    def set_client_phone(self, client_id, phone_number):
        """Define qual conversa o cliente está visualizando"""
        with self.client_lock:
            if client_id in self.clients:
                client = self.clients[client_id]
                
                # Remove do mapeamento anterior, se existir
                if client.phone_number and client.phone_number in self.client_phones:
                    if client_id in self.client_phones[client.phone_number]:
                        self.client_phones[client.phone_number].remove(client_id)
                
                # Define o novo número
                client.set_phone_number(phone_number)
                
                # Adiciona ao novo mapeamento
                if phone_number not in self.client_phones:
                    self.client_phones[phone_number] = []
                if client_id not in self.client_phones[phone_number]:
                    self.client_phones[phone_number].append(client_id)
                    
                print(f"Cliente {client_id} observando {phone_number}")
                
    def notify_new_message(self, phone_number, message_data):
        """Notifica sobre uma nova mensagem"""
        event = {
            "type": "new_message",
            "data": {
                "phone_number": phone_number,
                "message": message_data
            },
            "phone_number": phone_number
        }
        self.event_queue.put(event)
        print(f"Evento de nova mensagem para {phone_number} enfileirado")
        
    def notify_message_status(self, phone_number, message_id, status):
        """Notifica sobre mudança de status de uma mensagem"""
        event = {
            "type": "message_status",
            "data": {
                "phone_number": phone_number,
                "message_id": message_id,
                "status": status
            },
            "phone_number": phone_number
        }
        self.event_queue.put(event)
        print(f"Evento de status de mensagem para {phone_number} enfileirado")
        
    def notify_conversation_update(self, phone_number, update_type, data=None):
        """Notifica sobre atualizações gerais em uma conversa"""
        event = {
            "type": "conversation_update",
            "data": {
                "phone_number": phone_number,
                "update_type": update_type,
                "data": data or {}
            },
            "phone_number": phone_number
        }
        self.event_queue.put(event)
        print(f"Evento de atualização de conversa para {phone_number} enfileirado")
        
    def broadcast_system_event(self, event_type, data=None):
        """Envia um evento de sistema para todos os clientes"""
        event = {
            "type": event_type,
            "data": data or {},
            "phone_number": None  # Broadcast para todos
        }
        self.event_queue.put(event)
        print(f"Evento de sistema {event_type} enfileirado para broadcast")


def create_sse_endpoint(app, realtime_service):
    """Cria os endpoints SSE no aplicativo Flask"""
    
    @app.route('/events')
    def sse_stream():
        """Endpoint principal para conexões SSE"""
        # Verifica se o cliente suporta SSE
        if not request.headers.get('Accept') == 'text/event-stream':
            return "Este endpoint requer suporte a Server-Sent Events", 400
            
        # Recupera ou gera um ID de cliente
        client_id = request.args.get('client_id')
        if not client_id:
            client_id = str(uuid.uuid4())
            
        # Registra o cliente
        client = realtime_service.register_client(client_id)
        
        # Configura a resposta SSE
        def generate():
            # Envia evento inicial com o ID do cliente
            yield f"id:0\nevent:connected\ndata:{json.dumps({'client_id': client_id})}\n\n"
            
            try:
                # Loop principal para enviar eventos
                while True:
                    # Tenta obter um evento da fila do cliente
                    try:
                        event = client.queue.get(timeout=20.0)
                        event_id = event.get("id", 0)
                        event_type = event.get("type", "message")
                        event_data = json.dumps(event.get("data", {}))
                        
                        # Formata o evento SSE
                        yield f"id:{event_id}\nevent:{event_type}\ndata:{event_data}\n\n"
                        client.queue.task_done()
                    except Empty:
                        # Envia heartbeat se não houver eventos
                        yield f"event:heartbeat\ndata:{json.dumps({'timestamp': datetime.now().isoformat()})}\n\n"
            except GeneratorExit:
                # Cliente desconectou
                realtime_service.unregister_client(client_id)
            except Exception as e:
                print(f"Erro no stream de eventos: {str(e)}")
                realtime_service.unregister_client(client_id)
        
        response = Response(
            stream_with_context(generate()),
            content_type='text/event-stream'
        )
        
        # Configura cabeçalhos para SSE
        response.headers['Cache-Control'] = 'no-cache'
        response.headers['X-Accel-Buffering'] = 'no'  # Para Nginx
        response.headers['Connection'] = 'keep-alive'
        
        return response
        
    @app.route('/events/subscribe/<phone_number>', methods=['POST'])
    def subscribe_to_phone(phone_number):
        """Endpoint para assinar atualizações de um número específico"""
        client_id = request.json.get('client_id')
        if not client_id:
            return jsonify({"status": "error", "message": "client_id é obrigatório"}), 400
            
        realtime_service.set_client_phone(client_id, phone_number)
        
        # Marca mensagens como lidas quando o cliente se inscreve
        if phone_number in app.whatsapp_manager.conversations:
            # Atualiza o contador de não lidas
            if 'unread_count' not in app.whatsapp_manager.conversations[phone_number]:
                app.whatsapp_manager.conversations[phone_number]['unread_count'] = 0
                
            app.whatsapp_manager.conversations[phone_number]['unread_count'] = 0
            app.whatsapp_manager.save_conversation(phone_number)
            
            # Notifica outros clientes sobre a mudança
            realtime_service.notify_conversation_update(
                phone_number, 
                "unread_updated", 
                {"unread_count": 0}
            )
            
        return jsonify({"status": "success"})


def modify_whatsapp_manager(whatsapp_manager, realtime_service):
    """Modifica o WhatsAppManager para integrar com o RealtimeService"""
    
    # Salva referências originais dos métodos
    original_handle_incoming = whatsapp_manager.handle_incoming_message
    original_send_message = whatsapp_manager.send_message_to_whatsapp
    
    # Sobrescreve o método handle_incoming_message
    def enhanced_handle_incoming(data):
        phone_number = original_handle_incoming(data)
        
        if phone_number:
            # Obtém a última mensagem adicionada
            if phone_number in whatsapp_manager.conversations:
                conversation = whatsapp_manager.conversations[phone_number]
                if "messages" in conversation and conversation["messages"]:
                    last_message = conversation["messages"][-1]
                    
                    # Adiciona ID único se não existir
                    if "id" not in last_message:
                        last_message["id"] = str(uuid.uuid4())
                        whatsapp_manager.save_conversation(phone_number)
                    
                    # Incrementa contador de não lidas
                    if "unread_count" not in conversation:
                        conversation["unread_count"] = 0
                    conversation["unread_count"] += 1
                    whatsapp_manager.save_conversation(phone_number)
                    
                    # Notifica clientes sobre nova mensagem
                    realtime_service.notify_new_message(phone_number, last_message)
                    
                    # Notifica sobre atualização do contador de não lidas
                    realtime_service.notify_conversation_update(
                        phone_number,
                        "unread_updated",
                        {"unread_count": conversation["unread_count"]}
                    )
        
        return phone_number
    
    # Sobrescreve o método send_message_to_whatsapp
    def enhanced_send_message(to_number, message, media_type=None, media_path=None):
        # Gera ID único para a mensagem
        message_id = str(uuid.uuid4())
        
        # Adiciona a mensagem com status "sending"
        if to_number in whatsapp_manager.conversations:
            conversation = whatsapp_manager.conversations[to_number]
            sender = "qwen" if conversation.get("mode", "auto") == "auto" else "vendedor"
            timestamp = datetime.now().strftime("%H:%M %d/%m/%y")
            
            # Cria objeto de mensagem
            message_obj = {
                "id": message_id,
                "type": "text" if media_type is None else media_type,
                "content": message,
                "from": sender,
                "timestamp": timestamp,
                "status": "sending"
            }
            
            if media_type and media_path:
                message_obj["media_url"] = media_path
            
            # Adiciona à conversa
            if "messages" not in conversation:
                conversation["messages"] = []
            conversation["messages"].append(message_obj)
            whatsapp_manager.save_conversation(to_number)
            
            # Notifica clientes sobre nova mensagem
            realtime_service.notify_new_message(to_number, message_obj)
        
        # Chama o método original para enviar
        result = original_send_message(to_number, message, media_type, media_path)
        
        # Atualiza o status com base no resultado
        if to_number in whatsapp_manager.conversations:
            conversation = whatsapp_manager.conversations[to_number]
            if "messages" in conversation:
                for msg in reversed(conversation["messages"]):
                    if msg.get("id") == message_id:
                        msg["status"] = "delivered" if result else "failed"
                        whatsapp_manager.save_conversation(to_number)
                        
                        # Notifica sobre mudança de status
                        realtime_service.notify_message_status(
                            to_number,
                            message_id,
                            msg["status"]
                        )
                        break
        
        return result
    
    # Substitui os métodos originais
    whatsapp_manager.handle_incoming_message = enhanced_handle_incoming
    whatsapp_manager.send_message_to_whatsapp = enhanced_send_message
    
    # Adiciona método para marcar mensagens como lidas
    def mark_messages_read(phone_number):
        if phone_number in whatsapp_manager.conversations:
            conversation = whatsapp_manager.conversations[phone_number]
            if conversation.get("unread_count", 0) > 0:
                conversation["unread_count"] = 0
                whatsapp_manager.save_conversation(phone_number)
                
                # Notifica sobre atualização do contador
                realtime_service.notify_conversation_update(
                    phone_number,
                    "unread_updated",
                    {"unread_count": 0}
                )
                return True
        return False
    
    # Adiciona o novo método ao WhatsAppManager
    whatsapp_manager.mark_messages_read = mark_messages_read


def initialize_realtime_service(app, whatsapp_manager):
    """Inicializa o serviço de tempo real e o integra ao aplicativo Flask"""
    # Cria instância do serviço
    realtime_service = RealtimeService()
    
    # Inicia o serviço
    realtime_service.start()
    
    # Registra para limpeza ao desligar
    atexit.register(realtime_service.stop)
    
    # Cria endpoints SSE
    create_sse_endpoint(app, realtime_service)
    
    # Modifica o WhatsAppManager
    modify_whatsapp_manager(whatsapp_manager, realtime_service)
    
    # Armazena referência no aplicativo
    app.realtime_service = realtime_service
    
    # Adiciona rota para marcar mensagens como lidas
    @app.route('/mark_read/<phone_number>', methods=['POST'])
    def mark_read(phone_number):
        success = whatsapp_manager.mark_messages_read(phone_number)
        return jsonify({"status": "success" if success else "error"})
    
    # Adiciona rota para verificar status do serviço
    @app.route('/events/status', methods=['GET'])
    def service_status():
        return jsonify({
            "status": "online",
            "clients": len(realtime_service.clients),
            "timestamp": datetime.now().isoformat()
        })
    
    return realtime_service



    #########################   fim de realtime_service.py



    ################# início de notification_manager.js


    /**
 * notification_manager.js
 * 
 * Módulo responsável pelo gerenciamento de notificações e estados de leitura
 * Integra-se com o sistema SSE para atualizações em tempo real
 */

(function(App) {
    // Classe principal para gerenciamento de notificações
    class NotificationManager {
        constructor() {
            // Estado interno
            this.unreadCounts = {};           // Contador de mensagens não lidas por conversa
            this.totalUnreadCount = 0;        // Contador total de mensagens não lidas
            this.originalTitle = document.title; // Título original da página
            this.notificationsEnabled = false;   // Estado de permissão para notificações
            this.pageVisible = true;            // Estado de visibilidade da página
            this.titleInterval = null;          // Intervalo para alternar o título
            this.sseConnected = false;          // Estado da conexão SSE
            this.evtSource = null;              // Referência à conexão SSE
            
            // Inicialização
            this.init();
        }
        
        // Inicializa o gerenciador de notificações
        init() {
            console.log("Inicializando gerenciador de notificações...");
            
            // Verificar suporte a notificações
            this.checkNotificationSupport();
            
            // Monitorar visibilidade da página
            this.setupVisibilityTracking();
            
            // Estender métodos do App
            this.extendAppMethods();
            
            // Conectar ao serviço SSE
            this.connectToSSE();
            
            // Carregar contadores de mensagens não lidas
            this.loadUnreadCounts();
        }
        
        // Verifica se o navegador suporta notificações e solicita permissão
        checkNotificationSupport() {
            if (!("Notification" in window)) {
                console.log("Este navegador não suporta notificações desktop");
                return;
            }
            
            // Se já temos permissão
            if (Notification.permission === "granted") {
                this.notificationsEnabled = true;
                console.log("Notificações já estão habilitadas");
            } 
            // Se ainda não pedimos permissão
            else if (Notification.permission !== "denied") {
                Notification.requestPermission().then(permission => {
                    this.notificationsEnabled = (permission === "granted");
                    console.log("Permissão de notificações:", permission);
                });
            }
        }
        
        // Configura o monitoramento de visibilidade da página
        setupVisibilityTracking() {
            // Eventos de visibilidade
            document.addEventListener("visibilitychange", () => {
                this.pageVisible = !document.hidden;
                
                // Se a página ficar visível, parar a alternância do título
                if (this.pageVisible) {
                    this.stopTitleNotification();
                    
                    // Se temos uma conversa ativa, marcar como lida
                    if (App.currentPhone) {
                        this.markAsRead(App.currentPhone);
                    }
                }
            });
            
            // Eventos de foco da janela
            window.addEventListener("focus", () => {
                this.pageVisible = true;
                this.stopTitleNotification();
                
                // Se temos uma conversa ativa, marcar como lida
                if (App.currentPhone) {
                    this.markAsRead(App.currentPhone);
                }
            });
            
            window.addEventListener("blur", () => {
                this.pageVisible = false;
            });
            
            console.log("Monitoramento de visibilidade configurado");
        }
        
        // Método para conectar ao serviço SSE
        connectToSSE() {
            try {
                // Recupera o ID de cliente do localStorage ou cria um novo
                let clientId = localStorage.getItem('sse_client_id');
                if (!clientId) {
                    clientId = this.generateUUID();
                    localStorage.setItem('sse_client_id', clientId);
                }
                
                console.log("Conectando ao servidor SSE com ID:", clientId);
                
                // Inicia a conexão SSE
                const evtSource = new EventSource(`/events?client_id=${clientId}`);
                
                // Configura handlers para eventos
                evtSource.addEventListener("connected", (event) => {
                    const data = JSON.parse(event.data);
                    console.log("Conectado ao servidor SSE com ID:", data.client_id);
                    this.sseConnected = true;
                    
                    // Se temos uma conversa ativa, inscrever nela
                    if (App.currentPhone) {
                        this.subscribeToPhone(App.currentPhone);
                    }
                });
                
                // Evento de nova mensagem
                evtSource.addEventListener("new_message", (event) => {
                    const data = JSON.parse(event.data);
                    this.handleNewMessage(data);
                });
                
                // Evento de atualização de status de mensagem
                evtSource.addEventListener("message_status", (event) => {
                    const data = JSON.parse(event.data);
                    this.updateMessageStatus(data);
                });
                
                // Evento de atualização de conversa
                evtSource.addEventListener("conversation_update", (event) => {
                    const data = JSON.parse(event.data);
                    this.handleConversationUpdate(data);
                });
                
                // Evento de heartbeat (manter conexão viva)
                evtSource.addEventListener("heartbeat", () => {
                    // Apenas para manter a conexão ativa
                    console.log("Heartbeat recebido do servidor SSE");
                });
                
                // Tratamento de erros
                evtSource.onerror = (error) => {
                    console.error("Erro na conexão SSE:", error);
                    this.sseConnected = false;
                    
                    // Tentar reconectar após um tempo
                    setTimeout(() => {
                        if (!this.sseConnected) {
                            console.log("Tentando reconectar ao servidor SSE...");
                            this.connectToSSE();
                        }
                    }, 5000);
                };
                
                // Armazena a referência para poder fechar depois
                this.evtSource = evtSource;
                
                // Garantir que a conexão seja fechada ao sair da página
                window.addEventListener('beforeunload', () => {
                    if (this.evtSource) {
                        console.log("Fechando conexão SSE");
                        this.evtSource.close();
                    }
                });
            } catch (error) {
                console.error("Erro ao conectar ao SSE:", error);
            }
        }
        
        // Inscreve-se para receber atualizações de um número específico
        subscribeToPhone(phoneNumber) {
            if (!this.sseConnected) {
                console.log("Não é possível inscrever-se: SSE não conectado");
                return;
            }
            
            const clientId = localStorage.getItem('sse_client_id');
            if (!clientId) {
                console.log("Não é possível inscrever-se: ID de cliente não encontrado");
                return;
            }
            
            console.log(`Inscrevendo-se para atualizações do número ${phoneNumber}`);
            
            fetch(`/events/subscribe/${phoneNumber}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ client_id: clientId })
            })
            .then(response => response.json())
            .then(data => {
                console.log(`Inscrito para atualizações do número ${phoneNumber}`);
                
                // Marca mensagens como lidas quando nos inscrevemos
                this.markAsRead(phoneNumber);
            })
            .catch(error => {
                console.error(`Erro ao inscrever no número ${phoneNumber}:`, error);
            });
        }
        
        // Marca mensagens como lidas no servidor
        markAsRead(phoneNumber) {
            console.log(`Marcando mensagens como lidas para ${phoneNumber}`);
            
            fetch(`/mark_read/${phoneNumber}`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Atualiza o contador local
                    this.unreadCounts[phoneNumber] = 0;
                    this.updateTotalUnreadCount();
                    
                    // Atualiza a interface
                    this.updateConversationBadge(phoneNumber, 0);
                    console.log(`Mensagens marcadas como lidas para ${phoneNumber}`);
                }
            })
            .catch(error => {
                console.error(`Erro ao marcar mensagens como lidas para ${phoneNumber}:`, error);
            });
        }
        
        // Manipula evento de nova mensagem
        handleNewMessage(data) {
            const phoneNumber = data.phone_number;
            const message = data.message;
            
            console.log(`Nova mensagem recebida de ${phoneNumber}:`, message);
            
            // Verifica se a mensagem é de um cliente (não enviada por nós)
            if (message.from === 'cliente') {
                // Incrementa contador de não lidas se não estamos visualizando esta conversa
                if (App.currentPhone !== phoneNumber || !this.pageVisible) {
                    this.incrementUnreadCount(phoneNumber);
                    
                    // Exibe notificação se a página não estiver visível
                    if (!this.pageVisible) {
                        this.showNotification(phoneNumber, message);
                    }
                }
            }
            
            // Atualiza a interface se for a conversa atual
            if (App.currentPhone === phoneNumber) {
                App.updateConversationMessages(phoneNumber);
            } else {
                // Atualiza a lista de conversas para mostrar a última mensagem
                this.updateConversationPreview(phoneNumber, message);
            }
        }
        
        // Manipula atualizações de conversa
        handleConversationUpdate(data) {
            const phoneNumber = data.phone_number;
            const updateType = data.update_type;
            const updateData = data.data;
            
            console.log(`Atualização de conversa ${phoneNumber}, tipo: ${updateType}`, updateData);
            
            if (updateType === 'unread_updated') {
                const unreadCount = updateData.unread_count;
                
                // Atualiza o contador local
                this.unreadCounts[phoneNumber] = unreadCount;
                this.updateTotalUnreadCount();
                
                // Atualiza a interface
                this.updateConversationBadge(phoneNumber, unreadCount);
            }
        }
        
        // Incrementa o contador de mensagens não lidas
        incrementUnreadCount(phoneNumber) {
            if (!this.unreadCounts[phoneNumber]) {
                this.unreadCounts[phoneNumber] = 0;
            }
            
            this.unreadCounts[phoneNumber]++;
            this.updateTotalUnreadCount();
            
            console.log(`Incrementado contador para ${phoneNumber}: ${this.unreadCounts[phoneNumber]}`);
            
            // Atualiza a interface
            this.updateConversationBadge(phoneNumber, this.unreadCounts[phoneNumber]);
            
            // Inicia notificação no título se a página não estiver visível
            if (!this.pageVisible) {
                this.startTitleNotification();
            }
        }
        
        // Atualiza o contador total de mensagens não lidas
        updateTotalUnreadCount() {
            this.totalUnreadCount = Object.values(this.unreadCounts).reduce((total, count) => total + count, 0);
            
            console.log(`Total de mensagens não lidas: ${this.totalUnreadCount}`);
            
            // Atualiza o título da página se necessário
            if (this.totalUnreadCount > 0 && !this.titleInterval) {
                document.title = `(${this.totalUnreadCount}) ${this.originalTitle}`;
            } else if (this.totalUnreadCount === 0 && !this.titleInterval) {
                document.title = this.originalTitle;
            }
        }
        
        // Inicia a notificação no título (alternando)
        startTitleNotification() {
            if (this.titleInterval) return;
            
            console.log("Iniciando notificação no título");
            
            let showCount = true;
            this.titleInterval = setInterval(() => {
                if (showCount) {
                    document.title = `(${this.totalUnreadCount}) ${this.originalTitle}`;
                } else {
                    document.title = this.originalTitle;
                }
                showCount = !showCount;
            }, 1000);
        }
        
        // Para a notificação no título
        stopTitleNotification() {
            if (this.titleInterval) {
                clearInterval(this.titleInterval);
                this.titleInterval = null;
                
                console.log("Notificação no título parada");
                
                // Restaura o título com o contador, se houver mensagens não lidas
                if (this.totalUnreadCount > 0) {
                    document.title = `(${this.totalUnreadCount}) ${this.originalTitle}`;
                } else {
                    document.title = this.originalTitle;
                }
            }
        }
        
        // Exibe uma notificação desktop
        showNotification(phoneNumber, message) {
            if (!this.notificationsEnabled) {
                console.log("Notificações não estão habilitadas");
                return;
            }
            
            // Obtém informações da conversa
            const conversation = this.getConversationInfo(phoneNumber);
            const name = conversation ? conversation.name : phoneNumber;
            
            console.log(`Exibindo notificação para mensagem de ${name}`);
            
            // Cria o conteúdo da notificação
            let title = `Nova mensagem de ${name}`;
            let options = {
                body: message.type === 'text' ? message.content : `[${message.type.toUpperCase()}]`,
                icon: conversation && conversation.profile_pic ? conversation.profile_pic : '/static/images/default-avatar.png',
                tag: `whatsapp-${phoneNumber}`, // Agrupa notificações do mesmo contato
                requireInteraction: false // Não requer interação do usuário para fechar
            };
            
            // Cria e exibe a notificação
            const notification = new Notification(title, options);
            
            // Adiciona evento de clique na notificação
            notification.onclick = () => {
                // Foca na janela e carrega a conversa
                window.focus();
                App.loadConversation(phoneNumber);
                notification.close();
            };
            
            // Fecha automaticamente após 5 segundos
            setTimeout(() => {
                notification.close();
            }, 5000);
        }
        
        // Atualiza o badge de não lidas na lista de conversas
        updateConversationBadge(phoneNumber, count) {
            const conversationItem = document.querySelector(`.conversation-item[data-phone="${phoneNumber}"]`);
            if (!conversationItem) {
                console.log(`Conversa ${phoneNumber} não encontrada na interface`);
                return;
            }
            
            // Remove badge existente
            const existingBadge = conversationItem.querySelector('.unread-badge');
            if (existingBadge) {
                existingBadge.remove();
            }
            
            // Adiciona novo badge se houver mensagens não lidas
            if (count > 0) {
                const badge = document.createElement('div');
                badge.className = 'unread-badge';
                badge.textContent = count > 99 ? '99+' : count;
                
                // Adiciona o badge na posição correta
                const conversationInfo = conversationItem.querySelector('.conversation-info');
                conversationInfo.appendChild(badge);
                
                // Adiciona classe para destacar a conversa
                conversationItem.classList.add('has-unread');
                
                console.log(`Badge adicionado para ${phoneNumber}: ${count}`);
            } else {
                // Remove classe de destaque
                conversationItem.classList.remove('has-unread');
                console.log(`Badge removido para ${phoneNumber}`);
            }
        }
        
        // Atualiza a prévia da conversa na lista
        updateConversationPreview(phoneNumber, message) {
            const conversationItem = document.querySelector(`.conversation-item[data-phone="${phoneNumber}"]`);
            if (!conversationItem) {
                console.log(`Conversa ${phoneNumber} não encontrada para atualizar prévia`);
                return;
            }
            
            // Cria ou atualiza o elemento de prévia
            let previewElement = conversationItem.querySelector('.message-preview');
            if (!previewElement) {
                previewElement = document.createElement('div');
                previewElement.className = 'message-preview';
                
                // Adiciona após o nome/telefone
                const conversationInfo = conversationItem.querySelector('.conversation-info');
                conversationInfo.appendChild(previewElement);
            }
            
            // Define o conteúdo da prévia
            if (message.type === 'text') {
                previewElement.textContent = message.content.length > 30 ? 
                    message.content.substring(0, 27) + '...' : 
                    message.content;
            } else {
                previewElement.textContent = `[${message.type.toUpperCase()}]`;
            }
            
            console.log(`Prévia atualizada para ${phoneNumber}`);
            
            // Move a conversa para o topo da lista
            const conversationList = document.getElementById('conversation-list');
            if (conversationList && conversationList.firstChild) {
                conversationList.insertBefore(conversationItem, conversationList.firstChild);
                console.log(`Conversa ${phoneNumber} movida para o topo da lista`);
            }
        }
        
        // Atualiza os indicadores de status das mensagens
        updateMessageStatus(data) {
            const phoneNumber = data.phone_number;
            const messageId = data.message_id;
            const status = data.status;
            
            console.log(`Atualizando status de mensagem ${messageId} para ${status}`);
            
            // Atualiza apenas se for a conversa atual
            if (App.currentPhone !== phoneNumber) {
                console.log("Ignorando atualização de status para conversa não ativa");
                return;
            }
            
            // Encontra o elemento da mensagem
            const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!messageElement) {
                console.log(`Elemento de mensagem ${messageId} não encontrado`);
                return;
            }
            
            // Remove classes de status anteriores
            messageElement.classList.remove('status-sending', 'status-sent', 'status-delivered', 'status-failed');
            
            // Adiciona a classe de status atual
            messageElement.classList.add(`status-${status}`);
            
            // Atualiza o ícone de status
            let statusIcon = messageElement.querySelector('.message-status');
            if (!statusIcon) {
                statusIcon = document.createElement('div');
                statusIcon.className = 'message-status';
                messageElement.querySelector('.message-time').appendChild(statusIcon);
            }
            
            // Define o ícone apropriado
            switch (status) {
                case 'sending':
                    statusIcon.innerHTML = '<i class="fas fa-clock"></i>';
                    break;
                case 'sent':
                    statusIcon.innerHTML = '<i class="fas fa-check"></i>';
                    break;
                case 'delivered':
                    statusIcon.innerHTML = '<i class="fas fa-check-double"></i>';
                    break;
                case 'failed':
                    statusIcon.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
                    break;
            }
            
            console.log(`Status de mensagem ${messageId} atualizado para ${status}`);
        }
        
        // Obtém informações de uma conversa
        getConversationInfo(phoneNumber) {
            // Primeiro tenta obter da conversa atual
            if (App.currentPhone === phoneNumber && App.currentConversation) {
                return App.currentConversation;
            }
            
            // Tenta obter da lista de conversas
            const conversationItem = document.querySelector(`.conversation-item[data-phone="${phoneNumber}"]`);
            if (conversationItem) {
                const name = conversationItem.querySelector('.name').textContent;
                const profilePic = conversationItem.querySelector('.conversation-avatar img')?.src;
                
                return {
                    name: name,
                    profile_pic: profilePic,
                    phone: phoneNumber
                };
            }
            
            // Retorna informações básicas se não encontrar
            return {
                name: phoneNumber,
                profile_pic: null,
                phone: phoneNumber
            };
        }
        
        // Gera um UUID v4 para identificação de cliente
        generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Carrega os contadores de mensagens não lidas
        loadUnreadCounts() {
            console.log("Carregando contadores de mensagens não lidas");
            
            // Busca todas as conversas do servidor
            fetch('/all_conversations')
                .then(response => response.json())
                .then(conversations => {
                    // Inicializa os contadores
                    this.unreadCounts = {};
                    
                    // Processa cada conversa
                    for (const [phoneNumber, conversation] of Object.entries(conversations)) {
                        const unreadCount = conversation.unread_count || 0;
                        this.unreadCounts[phoneNumber] = unreadCount;
                        
                        // Atualiza a interface
                        this.updateConversationBadge(phoneNumber, unreadCount);
                    }
                    
                    // Atualiza o contador total
                    this.updateTotalUnreadCount();
                    
                    console.log("Contadores de mensagens não lidas carregados");
                })
                .catch(error => {
                    console.error("Erro ao carregar contadores de mensagens não lidas:", error);
                });
        }
        
        // Adiciona uma mensagem temporária à interface
        addTemporaryMessage(message, mediaInfo) {
            if (!App.currentPhone) return;
            
            console.log("Adicionando mensagem temporária");
            
            const messageArea = document.getElementById('message-area');
            const tempMsg = document.createElement('div');
            tempMsg.className = 'message vendedor temp-message status-sending';
            
            // Conteúdo da mensagem
            let content = '';
            
            if (mediaInfo) {
                // Mensagem com mídia
                switch (mediaInfo.type) {
                    case 'image':
                        content = `
                            <div class="message-media">
                                <img src="${mediaInfo.path}" alt="Imagem">
                            </div>
                            ${message ? `<div class="message-caption">${message}</div>` : ''}
                        `;
                        break;
                    case 'audio':
                        content = `
                            <div class="message-media">
                                <audio controls src="${mediaInfo.path}"></audio>
                            </div>
                            ${message ? `<div class="message-caption">${message}</div>` : ''}
                        `;
                        break;
                    case 'video':
                        content = `
                            <div class="message-media">
                                <video controls src="${mediaInfo.path}"></video>
                            </div>
                            ${message ? `<div class="message-caption">${message}</div>` : ''}
                        `;
                        break;
                    case 'document':
                        const fileName = mediaInfo.path.split('/').pop();
                        content = `
                            <div class="message-document">
                                <a href="${mediaInfo.path}" class="document-link" target="_blank">
                                    <i class="fas fa-file"></i> ${fileName}
                                </a>
                            </div>
                            ${message ? `<div class="message-caption">${message}</div>` : ''}
                        `;
                        break;
                }
            } else {
                // Mensagem de texto simples
                content = `<div class="message-text">${message}</div>`;
            }
            
            // Adiciona o conteúdo e o indicador de status
            tempMsg.innerHTML = `
                ${content}
                <div class="message-time">
                    Enviando...
                    <div class="message-status"><i class="fas fa-clock"></i></div>
                </div>
            `;
            
            // Adiciona à área de mensagens
            messageArea.appendChild(tempMsg);
            
            // Rola para o final
            messageArea.scrollTop = messageArea.scrollHeight;
            
            console.log("Mensagem temporária adicionada");
        }
        
        // Extensão do método loadConversation do App para integrar com o gerenciador de notificações
        extendAppMethods() {
            console.log("Estendendo métodos do App");
            
            // Adiciona método para atualizar mensagens da conversa atual
            App.updateConversationMessages = function(phoneNumber) {
                // Verifica se é a conversa atual
                if (this.currentPhone !== phoneNumber) return;
                
                console.log(`Atualizando mensagens da conversa ${phoneNumber}`);
                
                // Busca os dados atualizados da conversa
                fetch(`/conversation/${phoneNumber}`)
                    .then(response => response.json())
                    .then(data => {
                        // Atualiza o objeto de conversa atual
                        this.currentConversation = data;
                        
                        // Atualiza a área de mensagens
                        const messageArea = document.getElementById('message-area');
                        
                        // Salva a posição de rolagem atual
                        const wasAtBottom = messageArea.scrollHeight - messageArea.scrollTop <= messageArea.clientHeight + 50;
                        
                        // Obtém as mensagens existentes
                        const existingMessages = Array.from(messageArea.querySelectorAll('.message')).map(el => el.dataset.messageId).filter(Boolean);
                        
                        // Adiciona apenas novas mensagens
                        if (data.messages && data.messages.length > 0) {
                            data.messages.forEach(msg => {
                                // Verifica se a mensagem já existe
                                if (!msg.id || existingMessages.includes(msg.id)) return;
                                
                                // Cria e adiciona o elemento da mensagem
                                const messageElement = this.createMessageElement(msg);
                                messageArea.appendChild(messageElement);
                                
                                // Adiciona o ID à lista de mensagens existentes
                                if (msg.id) {
                                    existingMessages.push(msg.id);
                                }
                            });
                            
                            // Rola para o final se estava no final antes
                            if (wasAtBottom) {
                                messageArea.scrollTop = messageArea.scrollHeight;
                            }
                        }
                        
                        // Atualiza também a área de IA
                        this.updateAIMessages(data);
                        
                        console.log(`Mensagens da conversa ${phoneNumber} atualizadas`);
                    })
                    .catch(error => {
                        console.error("Erro ao atualizar mensagens:", error);
                    });
            };
            
            // Adiciona método para atualizar a área de mensagens da IA
            App.updateAIMessages = function(data) {
                const aiMessageArea = document.getElementById('ai-message-area');
                
                // Filtra as interações com a IA
                const aiInteractions = data.messages.filter(msg => 
                    msg.from === 'cliente' || msg.from === 'qwen' || msg.from === 'deepseek'
                );
                
                console.log(`Atualizando ${aiInteractions.length} interações com a IA`);
                
                // Limpa e reconstrói a área de mensagens da IA
                aiMessageArea.innerHTML = '';
                
                if (aiInteractions.length === 0) {
                    aiMessageArea.innerHTML = '<div class="empty-state">Nenhuma interação com a IA ainda</div>';
                } else {
                    aiInteractions.forEach(msg => {
                        const messageElement = this.createAIMessageElement(msg);
                        aiMessageArea.appendChild(messageElement);
                    });
                    
                    // Rola para a última mensagem
                    aiMessageArea.scrollTop = aiMessageArea.scrollHeight;
                }
            };
            
            // Salva referência ao método original
            const originalLoadConversation = App.loadConversation;
            
            // Sobrescreve o método com versão estendida
            App.loadConversation = function(phoneNumber) {
                console.log(`Carregando conversa ${phoneNumber} com notificações`);
                
                // Chama o método original
                originalLoadConversation.call(App, phoneNumber);
                
                // Adiciona comportamento de notificação
                if (App.notificationManager) {
                    // Inscreve-se para atualizações deste número
                    App.notificationManager.subscribeToPhone(phoneNumber);
                    
                    // Marca mensagens como lidas
                    App.notificationManager.markAsRead(phoneNumber);
                }
            };
            
            // Salva referência ao método original
            const originalCreateMessageElement = App.createMessageElement;
            
            // Sobrescreve o método com versão estendida
            App.createMessageElement = function(msg) {
                // Chama o método original
                const element = originalCreateMessageElement.call(App, msg);
                
                // Adiciona ID da mensagem como atributo do elemento
                if (msg.id) {
                    element.dataset.messageId = msg.id;
                }
                
                // Adiciona indicador de status para mensagens enviadas por nós
                if (msg.from === 'vendedor' || msg.from === 'qwen') {
                    // Adiciona classe de status
                    element.classList.add(`status-${msg.status || 'sent'}`);
                    // Adiciona ícone de status
                    const timeElement = element.querySelector('.message-time');
                    if (timeElement) {
                        const statusIcon = document.createElement('div');
                        statusIcon.className = 'message-status';
                        
                        // Define o ícone apropriado
                        switch (msg.status) {
                            case 'sending':
                                statusIcon.innerHTML = '<i class="fas fa-clock"></i>';
                                break;
                            case 'sent':
                                statusIcon.innerHTML = '<i class="fas fa-check"></i>';
                                break;
                            case 'delivered':
                                statusIcon.innerHTML = '<i class="fas fa-check-double"></i>';
                                break;
                            case 'failed':
                                statusIcon.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
                                break;
                            default:
                                statusIcon.innerHTML = '<i class="fas fa-check"></i>';
                        }
                        
                        timeElement.appendChild(statusIcon);
                    }
                }
                
                return element;
            };
            
            // Salva referência ao método original de envio de mensagem
            const originalSendMessage = App.sendMessage;
            
            // Sobrescreve o método com versão estendida
            App.sendMessage = function() {
                // Bloqueia múltiplos envios
                if (this.isSubmitting) return;
                this.isSubmitting = true;
            
                if (!App.currentPhone) {
                    alert("Selecione uma conversa primeiro!");
                    this.isSubmitting = false;
                    return;
                }
                
                const messageInput = document.getElementById('message-input');
                const message = messageInput.value.trim();
                
                if (!message && !App.mediaInfo) {
                    alert("Digite uma mensagem ou selecione uma mídia!");
                    this.isSubmitting = false;
                    return;
                }
                
                const data = {
                    to_number: App.currentPhone,
                    message: message
                };
                
                if (App.mediaInfo) {
                    data.media_path = App.mediaInfo.path;
                    data.media_type = App.mediaInfo.type;
                }
                
                const sendButton = document.getElementById('send-button');
                sendButton.disabled = true;
                
                // Feedback visual imediato
                if (App.notificationManager) {
                    App.notificationManager.addTemporaryMessage(message, App.mediaInfo);
                }
                messageInput.value = '';
                
                fetch('/send_message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error("Erro ao enviar mensagem");
                    }
                    return response.json();
                })
                .then(result => {
                    // Limpa a mídia após envio
                    App.mediaInfo = null;
                    
                    // Remove mensagens temporárias (caso ainda existam)
                    document.querySelectorAll('.temp-message').forEach(el => el.remove());
                    
                    console.log("Mensagem enviada com sucesso");
                })
                .catch(error => {
                    console.error("Erro:", error);
                    alert("Não foi possível enviar a mensagem");
                    
                    // Remove mensagens temporárias em caso de erro
                    document.querySelectorAll('.temp-message').forEach(el => el.remove());
                    
                    // Restaura a mensagem não enviada
                    messageInput.value = message;
                })
                .finally(() => {
                    this.isSubmitting = false;
                    sendButton.disabled = false;
                });
            };
            
            console.log("Métodos do App estendidos com sucesso");
        }
    }
    
    // Adiciona estilos CSS necessários
    function addStyles() {
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            /* Estilos para badges de mensagens não lidas */
            .unread-badge {
                background-color: #25D366;
                color: white;
                border-radius: 50%;
                min-width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
                margin-left: 8px;
                padding: 0 4px;
            }

            /* Destaque para conversas com mensagens não lidas */
            .conversation-item.has-unread {
                font-weight: bold;
                background-color: rgba(37, 211, 102, 0.1);
            }

            /* Prévia da última mensagem */
            .message-preview {
                font-size: 12px;
                color: #666;
                margin-top: 2px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 200px;
            }

            /* Indicadores de status de mensagem */
            .message-status {
                display: inline-block;
                margin-left: 5px;
                font-size: 12px;
            }

            .status-sending .message-status {
                color: #999;
            }

            .status-sent .message-status {
                color: #999;
            }

            .status-delivered .message-status {
                color: #25D366;
            }

            .status-failed .message-status {
                color: #FF3B30;
            }
            
            /* Mensagem temporária */
            .temp-message {
                opacity: 0.7;
            }
        `;
        document.head.appendChild(styleElement);
        console.log("Estilos CSS adicionados");
    }
    
    // Inicializa o módulo quando o documento estiver pronto
    function initialize() {
        console.log("Inicializando módulo notification_manager.js");
        
        // Adiciona estilos CSS
        addStyles();
        
        // Instancia e expõe o gerenciador de notificações no objeto App
        App.notificationManager = new NotificationManager();
    }
    
    // Verifica se o documento já está carregado
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
    
})(window.App || (window.App = {}));



###################### fim de notification_manager.js



################### inicio de persistence_handler.js


/**
 * persistence_handler.js
 * 
 * Módulo responsável pelo gerenciamento de persistência de estado e configurações
 * Permite restaurar o estado da aplicação entre sessões e recarregamentos
 */

(function(App) {
    // Classe principal para gerenciamento de persistência
    class PersistenceHandler {
        constructor() {
            // Configurações padrão
            this.defaultSettings = {
                notifications: true,
                enterToSend: true,
                lastConversation: null,
                unreadCounters: {},
                lastActive: Date.now(),
                tabId: this.generateUUID()
            };
            
            // Estado atual
            this.settings = {};
            this._eventListeners = [];
            
            // Inicialização
            this.init();
        }
        
        // Inicializa o gerenciador de persistência
        init() {
            console.log("Inicializando gerenciador de persistência...");
            
            // Carrega configurações salvas ou usa padrões
            this.loadSettings();
            
            // Configura observadores de URL
            this.setupUrlHandling();
            
            // Configura sincronização entre abas
            this.setupTabSynchronization();
            
            // Estende os métodos do App
            this.extendAppMethods();
            
            // Restaura o estado da última sessão
            this.restoreLastState();
            
            // Configura evento de salvamento automático ao fechar
            window.addEventListener('beforeunload', () => {
                this.saveScrollPositions();
            });
            
            // Registra atividade periódica desta aba
            setInterval(() => this.registerTabActivity(), 30000);
            this.registerTabActivity();
            
            console.log("Gerenciador de persistência inicializado");
        }
        
        // Carrega configurações do localStorage
        loadSettings() {
            try {
                const savedSettings = localStorage.getItem('app_settings');
                if (savedSettings) {
                    this.settings = JSON.parse(savedSettings);
                    console.log("Configurações carregadas do armazenamento local");
                } else {
                    // Usa configurações padrão se não houver salvas
                    this.settings = {...this.defaultSettings};
                    console.log("Usando configurações padrão");
                }
                
                // Garante que todas as propriedades padrão existam
                for (const key in this.defaultSettings) {
                    if (this.settings[key] === undefined) {
                        this.settings[key] = this.defaultSettings[key];
                    }
                }
            } catch (error) {
                console.error("Erro ao carregar configurações:", error);
                this.settings = {...this.defaultSettings};
            }
        }
        
        // Salva as configurações no localStorage
        saveSettings() {
            try {
                localStorage.setItem('app_settings', JSON.stringify(this.settings));
            } catch (error) {
                console.error("Erro ao salvar configurações:", error);
            }
        }
        
        // Salva a conversa atual no localStorage e URL
        saveCurrentConversation(phoneNumber) {
            if (!phoneNumber) return;
            
            // Atualiza as configurações
            this.settings.lastConversation = phoneNumber;
            this.saveSettings();
            
            // Atualiza a URL sem recarregar a página
            const url = new URL(window.location);
            url.searchParams.set('phone', phoneNumber);
            window.history.pushState({phone: phoneNumber}, '', url);
            
            console.log(`Conversa ${phoneNumber} salva como atual`);
        }
        
        // Restaura o estado completo da última sessão
        restoreLastState() {
            // Restaura a última conversa
            const conversationRestored = this.restoreLastConversation();
            
            // Restaura posições de scroll
            setTimeout(() => {
                this.restoreScrollPositions();
            }, 500);
            
            console.log("Estado da aplicação restaurado");
            return conversationRestored;
        }
        
        // Restaura a última conversa ativa
        restoreLastConversation() {
            // Primeiro verifica parâmetros de URL
            const urlParams = new URLSearchParams(window.location.search);
            const phoneFromUrl = urlParams.get('phone');
            
            if (phoneFromUrl) {
                console.log(`Restaurando conversa ${phoneFromUrl} da URL`);
                // Verifica se a conversa existe antes de carregar
                this.loadConversationIfExists(phoneFromUrl);
                return true;
            }
            
            // Se não houver na URL, tenta do localStorage
            const lastPhone = this.settings.lastConversation;
            if (lastPhone) {
                console.log(`Restaurando última conversa ${lastPhone}`);
                this.loadConversationIfExists(lastPhone);
                return true;
            }
            
            console.log("Nenhuma conversa anterior para restaurar");
            return false;
        }
        
        // Verifica se a conversa existe antes de carregar
        loadConversationIfExists(phoneNumber) {
            // Verifica se o elemento da conversa existe no DOM
            const conversationElement = document.querySelector(`.conversation-item[data-phone="${phoneNumber}"]`);
            
            if (conversationElement) {
                // Usa o método existente para carregar a conversa
                App.loadConversation(phoneNumber);
                return true;
            } else {
                // Tenta buscar a conversa do servidor
                fetch(`/conversation/${phoneNumber}`)
                    .then(response => {
                        if (response.ok) {
                            return response.json();
                        }
                        throw new Error("Conversa não encontrada");
                    })
                    .then(data => {
                        // Verifica se a conversa já foi adicionada ao DOM (pode ter sido carregada durante a requisição)
                        if (!document.querySelector(`.conversation-item[data-phone="${phoneNumber}"]`)) {
                            // Cria um novo elemento na lista de conversas
                            this.createConversationElement(phoneNumber, data);
                        }
                        
                        // Carrega a conversa
                        App.loadConversation(phoneNumber);
                    })
                    .catch(error => {
                        console.warn(`Conversa ${phoneNumber} não pôde ser restaurada:`, error);
                        // Remove dos dados salvos já que não existe mais
                        if (this.settings.lastConversation === phoneNumber) {
                            this.settings.lastConversation = null;
                            this.saveSettings();
                        }
                    });
                return false;
            }
        }
        
        // Cria um elemento de conversa na lista
        createConversationElement(phoneNumber, data) {
            const conversationList = document.getElementById('conversation-list');
            if (!conversationList) return;
            
            const newConversation = document.createElement('div');
            newConversation.className = 'conversation-item';
            newConversation.setAttribute('data-phone', phoneNumber);
            newConversation.onclick = function() { App.loadConversation(phoneNumber); };
            
            const name = data.name || "Novo Contato";
            const profilePic = data.profile_pic || "";
            const mode = data.mode || "auto";
            
            newConversation.innerHTML = `
                <div class="conversation-avatar">
                    ${profilePic ? 
                        `<img src="${App.getMediaUrl(profilePic)}" alt="${name}">` : 
                        `<div class="avatar-placeholder">${name[0].toUpperCase()}</div>`}
                </div>
                <div class="conversation-info">
                    <div class="name">${name}</div>
                    <div class="phone">${phoneNumber}</div>
                </div>
                <div class="conversation-actions-hover">
                    <button class="action-btn delete-btn" onclick="event.stopPropagation(); App.confirmDeleteConversation('${phoneNumber}')">
                        <i class="fas fa-trash"></i>
                    </button>
                    <button class="action-btn archive-btn" onclick="event.stopPropagation(); alert('Função de arquivar será implementada em breve!')">
                        <i class="fas fa-archive"></i>
                    </button>
                </div>
                <div class="conversation-mode">
                    <div class="mode-toggle ${mode === 'human' ? 'human-mode' : 'auto-mode'}" 
                            onclick="event.stopPropagation(); App.toggleMode()">
                        <i class="fas ${mode === 'human' ? 'fa-user' : 'fa-robot'}"></i>
                    </div>
                </div>
            `;
            
            // Adiciona à lista de conversas
            conversationList.prepend(newConversation);
        }
        
        // Salva posições de scroll
        saveScrollPositions() {
            const messageArea = document.getElementById('message-area');
            const conversationList = document.getElementById('conversation-list');
            
            if (messageArea) {
                this.settings.messageAreaScroll = messageArea.scrollTop;
            }
            
            if (conversationList) {
                this.settings.conversationListScroll = conversationList.scrollTop;
            }
            
            this.saveSettings();
        }
        
        // Restaura posições de scroll
        restoreScrollPositions() {
            const messageArea = document.getElementById('message-area');
            const conversationList = document.getElementById('conversation-list');
            
            if (messageArea && this.settings.messageAreaScroll !== undefined) {
                messageArea.scrollTop = this.settings.messageAreaScroll;
            }
            
            if (conversationList && this.settings.conversationListScroll !== undefined) {
                conversationList.scrollTop = this.settings.conversationListScroll;
            }
        }
        
        // Configura o tratamento de URL
        setupUrlHandling() {
            // Observa mudanças na URL
            window.addEventListener('popstate', (event) => {
                console.log("Navegação detectada:", event.state);
                
                // Restaura estado baseado no evento de histórico
                if (event.state && event.state.phone) {
                    this.loadConversationIfExists(event.state.phone);
                } else {
                    // Se não houver estado, limpa a conversa atual
                    this.clearCurrentConversation();
                }
            });
            
            // Inicializa o estado do histórico
            const currentState = {
                phone: this.settings.lastConversation
            };
            
            // Substitui o estado atual sem modificar a URL
            window.history.replaceState(currentState, '', window.location.href);
        }
        
        // Gera URL compartilhável para a conversa atual
        generateShareableUrl() {
            if (!App.currentPhone) return null;
            
            const url = new URL(window.location.origin);
            url.pathname = window.location.pathname;
            url.searchParams.set('phone', App.currentPhone);
            
            return url.toString();
        }
        
        // Compartilha a URL da conversa atual
        shareConversationUrl() {
            const url = this.generateShareableUrl();
            if (!url) {
                alert("Selecione uma conversa para compartilhar");
                return;
            }
            
            // Usa a API de compartilhamento se disponível
            if (navigator.share) {
                navigator.share({
                    title: 'Conversa WhatsApp',
                    text: 'Acesse esta conversa:',
                    url: url
                })
                .then(() => console.log('URL compartilhada com sucesso'))
                .catch((error) => console.error('Erro ao compartilhar:', error));
            } else {
                // Fallback: copia para a área de transferência
                navigator.clipboard.writeText(url)
                    .then(() => {
                        alert("URL copiada para a área de transferência");
                    })
                    .catch((error) => {
                        console.error('Erro ao copiar URL:', error);
                        alert("Não foi possível copiar a URL: " + error);
                    });
            }
        }
        
        // Limpa a conversa atual
        clearCurrentConversation() {
            App.currentPhone = null;
            App.currentConversation = null;
            
            // Atualiza a interface
            document.getElementById('message-area').innerHTML = 
                '<div class="empty-state">Selecione uma conversa para ver as mensagens</div>';
            document.getElementById('ai-message-area').innerHTML = 
                '<div class="empty-state">Informações da IA aparecerão aqui quando uma conversa estiver ativa</div>';
            document.getElementById('current-contact-name').textContent = 'Selecione uma conversa';
            document.getElementById('current-contact-avatar').innerHTML = '<div class="avatar-placeholder">?</div>';
            document.getElementById('toggle-mode-btn').style.display = 'none';
            
            // Remove seleção na lista de conversas
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Atualiza o estado salvo
            this.settings.lastConversation = null;
            this.saveSettings();
            
            // Atualiza a URL sem recarregar a página
            const url = new URL(window.location);
            url.searchParams.delete('phone');
            window.history.pushState({phone: null}, '', url);
        }
        
        // Configura sincronização entre abas
        setupTabSynchronization() {
            // Escuta eventos de storage para detectar mudanças em outras abas
            window.addEventListener('storage', (event) => {
                if (event.key === 'app_settings') {
                    console.log("Configurações alteradas em outra aba");
                    
                    try {
                        // Recarrega as configurações do localStorage
                        const newSettings = JSON.parse(event.newValue);
                        
                        // Atualiza apenas se forem diferentes das atuais
                        if (JSON.stringify(this.settings) !== JSON.stringify(newSettings)) {
                            // Preserva o ID desta aba
                            const currentTabId = this.settings.tabId;
                            
                            // Atualiza as configurações
                            this.settings = newSettings;
                            
                            // Restaura o ID desta aba
                            this.settings.tabId = currentTabId;
                            
                            // Atualiza contadores de não lidos
                            if (App.notificationManager) {
                                App.notificationManager.updateUnreadCounters(this.settings.unreadCounters || {});
                            }
                            
                            // Se a conversa atual mudou, atualiza
                            if (App.currentPhone !== this.settings.lastConversation && this.settings.lastConversation) {
                                this.loadConversationIfExists(this.settings.lastConversation);
                            }
                        }
                    } catch (error) {
                        console.error("Erro ao processar alterações de outra aba:", error);
                    }
                }
            });
        }
        
        // Registra que esta aba está ativa
        registerTabActivity() {
            // Atualiza timestamp de última atividade
            this.settings.lastActive = Date.now();
            this.saveSettings();
            
            // Armazena também separadamente para outras abas consultarem
            localStorage.setItem(`tab_activity_${this.settings.tabId}`, this.settings.lastActive.toString());
            
            // Limpa registros de abas antigas (mais de 1 hora)
            this.cleanupOldTabs();
        }
        
        // Remove registros de abas inativas
        cleanupOldTabs() {
            const oneHourAgo = Date.now() - (60 * 60 * 1000);
            
            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                if (key && key.startsWith('tab_activity_')) {
                    const lastActive = parseInt(localStorage.getItem(key) || '0');
                    if (lastActive < oneHourAgo) {
                        localStorage.removeItem(key);
                    }
                }
            }
        }
        
        // Gera um UUID para identificação da aba
        generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Atualiza uma configuração específica
        updateSetting(key, value) {
            if (key in this.settings) {
                this.settings[key] = value;
                this.saveSettings();
                console.log(`Configuração ${key} atualizada para ${value}`);
                return true;
            }
            return false;
        }
        
        // Atualiza contadores de mensagens não lidas
        updateUnreadCounters(unreadCounts) {
            this.settings.unreadCounters = unreadCounts;
            this.saveSettings();
        }
        
        // Limpa todos os dados salvos
        clearAllData() {
            if (confirm("Tem certeza que deseja limpar todas as configurações salvas? Isso não afetará suas conversas.")) {
                localStorage.removeItem('app_settings');
                localStorage.removeItem('sse_client_id');
                
                // Remove também dados de atividade de abas
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('tab_activity_')) {
                        localStorage.removeItem(key);
                    }
                }
                
                // Recarrega a página para aplicar as configurações padrão
                window.location.reload();
            }
        }
        
        // Método para estender os métodos do App
        extendAppMethods() {
            console.log("Estendendo métodos do App com funcionalidades de persistência");
            
            // Salva referência ao método original de carregamento de conversa
            const originalLoadConversation = App.loadConversation;
            
            // Sobrescreve o método com versão que salva o estado
            App.loadConversation = function(phoneNumber) {
                // Chama o método original
                originalLoadConversation.call(App, phoneNumber);
                
                // Salva o estado da conversa
                if (App.persistenceHandler) {
                    App.persistenceHandler.saveCurrentConversation(phoneNumber);
                }
            };
            
            // Adiciona método para compartilhar conversa
            App.shareConversation = function() {
                if (App.persistenceHandler) {
                    App.persistenceHandler.shareConversationUrl();
                }
            };
            
            // Adiciona método para salvar configurações
            App.saveSetting = function(key, value) {
                if (App.persistenceHandler) {
                    return App.persistenceHandler.updateSetting(key, value);
                }
                return false;
            };
            
            // Adiciona método para obter configurações
            App.getSetting = function(key) {
                if (App.persistenceHandler && App.persistenceHandler.settings) {
                    return App.persistenceHandler.settings[key];
                }
                return null;
            };
            
            // Integração com o gerenciador de notificações
            if (App.notificationManager) {
                // Salva referência ao método original
                const originalUpdateTotalUnreadCount = App.notificationManager.updateTotalUnreadCount;
                
                // Sobrescreve o método para salvar contadores
                App.notificationManager.updateTotalUnreadCount = function() {
                    // Chama o método original
                    originalUpdateTotalUnreadCount.call(App.notificationManager);
                    
                    // Salva os contadores no persistenceHandler
                    if (App.persistenceHandler) {
                        App.persistenceHandler.updateUnreadCounters(this.unreadCounts);
                    }
                };
                
                // Adiciona método para atualizar contadores a partir do persistenceHandler
                App.notificationManager.updateUnreadCounters = function(counters) {
                    // Atualiza apenas se houver mudanças
                    if (JSON.stringify(this.unreadCounts) !== JSON.stringify(counters)) {
                        this.unreadCounts = {...counters};
                        this.updateTotalUnreadCount();
                        
                        // Atualiza badges na interface
                        for (const [phone, count] of Object.entries(this.unreadCounts)) {
                            this.updateConversationBadge(phone, count);
                        }
                    }
                };
                
                // Carrega contadores salvos
                if (App.persistenceHandler.settings.unreadCounters) {
                    App.notificationManager.updateUnreadCounters(App.persistenceHandler.settings.unreadCounters);
                }
            }
            
            // Adiciona comando para compartilhar conversa
            if (App.registerCommand) {
                App.registerCommand('compartilhar', {
                    description: 'Compartilhar link para esta conversa',
                    handler: () => App.shareConversation()
                });
            }
        }
    }
    
    // Adiciona estilos CSS necessários
    function addStyles() {
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            /* Estilos para compartilhamento */
            .share-button {
                background-color: #25D366;
                color: white;
                border: none;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                margin-left: 10px;
                transition: background-color 0.3s;
            }
            
            .share-button:hover {
                background-color: #128C7E;
            }
            
            /* Estilos para notificação de cópia */
            .copy-notification {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                z-index: 1000;
                animation: fadeInOut 2s ease-in-out;
            }
            
            @keyframes fadeInOut {
                0% { opacity: 0; }
                20% { opacity: 1; }
                80% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(styleElement);
    }
    
    // Adiciona botão de compartilhamento à interface
    function addShareButton() {
        const headerActions = document.querySelector('.conversation-actions');
        if (!headerActions) return;
        
        // Verifica se o botão já existe
        if (headerActions.querySelector('.share-button')) return;
        
        // Cria o botão
        const shareButton = document.createElement('button');
        shareButton.className = 'share-button';
        shareButton.innerHTML = '<i class="fas fa-share-alt"></i>';
        shareButton.title = 'Compartilhar link para esta conversa';
        shareButton.onclick = () => App.shareConversation();
        
        // Adiciona à interface
        headerActions.appendChild(shareButton);
    }
    
    // Inicializa o módulo quando o documento estiver pronto
    function initialize() {
        console.log("Inicializando módulo persistence_handler.js");
        
        // Adiciona estilos CSS
        addStyles();
        
        // Adiciona botão de compartilhamento
        setTimeout(addShareButton, 500);
        
        // Instancia e expõe o gerenciador de persistência no objeto App
        App.persistenceHandler = new PersistenceHandler();
        
        // Observa mudanças na interface para adicionar botão de compartilhamento quando necessário
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === 'childList' && 
                    (mutation.target.classList.contains('header') || 
                     mutation.target.classList.contains('conversation-actions'))) {
                    addShareButton();
                }
            }
        });
        
        // Observa mudanças no header
        const header = document.querySelector('.header');
        if (header) {
            observer.observe(header, { childList: true, subtree: true });
        }
    }
    
    // Verifica se o documento já está carregado
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
    
})(window.App || (window.App = {}));




################## fim de persistence_handler.py








